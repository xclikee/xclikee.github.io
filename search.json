[{"title":"Unity 检测窗口是否被完全遮挡","path":"/2025/03/22/Unity-检测窗口是否被完全遮挡/","content":"废话不多说直接上代码 测试代码123456789101112131415161718192021void TestFun()&#123; // 此处需要写unity程序的标题 IntPtr handle = Win32Api.GetProcessWnd(&quot;测试窗口&quot;); // WPF 程序需要这样使用 // IntPtr currentIntPtr = new WindowInteropHelper(this).Handle; if (Win32Api.IsCover(handle)) &#123; Console.WriteLine(&quot;窗口被完全遮挡&quot;); &#125; else &#123; Console.WriteLine(&quot;窗口未被完全遮挡&quot;); &#125;&#125; 系统API123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236internal class Win32Api&#123; [StructLayout(LayoutKind.Sequential)] public struct Rect &#123; public int Left; public int Top; public int Right; public int Bottom; &#125; /// &lt;summary&gt; /// 获取 Win32 窗口的一些基本信息。 /// &lt;/summary&gt; public readonly struct WindowInfo &#123; public WindowInfo(IntPtr hWnd, string className, string title, bool isVisible, Rectangle bounds) : this() &#123; Hwnd = hWnd; ClassName = className; Title = title; IsVisible = isVisible; Bounds = bounds; &#125; /// &lt;summary&gt; /// 获取窗口句柄。 /// &lt;/summary&gt; public IntPtr Hwnd &#123; get; &#125; /// &lt;summary&gt; /// 获取窗口类名。 /// &lt;/summary&gt; public string ClassName &#123; get; &#125; /// &lt;summary&gt; /// 获取窗口标题。 /// &lt;/summary&gt; public string Title &#123; get; &#125; /// &lt;summary&gt; /// 获取当前窗口是否可见。 /// &lt;/summary&gt; public bool IsVisible &#123; get; &#125; /// &lt;summary&gt; /// 获取窗口当前的位置和尺寸。 /// &lt;/summary&gt; public Rectangle Bounds &#123; get; &#125; /// &lt;summary&gt; /// 获取窗口当前是否是最小化的。 /// &lt;/summary&gt; public bool IsMinimized =&gt; Bounds.Left == -32000 &amp;&amp; Bounds.Top == -32000; &#125; [DllImport(&quot;user32.dll&quot;, SetLastError = true)] public static extern IntPtr GetWindow(IntPtr hwnd, uint windowType); public delegate bool WNDENUMPROC(IntPtr hwnd, int lParam); [DllImport(&quot;user32.dll&quot;, SetLastError = true)] public static extern bool EnumWindows(WNDENUMPROC lpEnumFunc, uint lParam); [DllImport(&quot;user32.dll&quot;, SetLastError = true)] public static extern IntPtr GetParent(IntPtr hWnd); [DllImport(&quot;user32.dll&quot;)] public static extern uint GetWindowThreadProcessId(IntPtr hWnd, ref uint lpdwProcessId); [DllImport(&quot;user32.dll&quot;)] public static extern int GetWindowTextLength(IntPtr hWnd); [DllImport(&quot;User32.dll&quot;, CharSet = CharSet.Auto)] public static extern int GetWindowText(IntPtr hWnd, StringBuilder text, int nMaxCount); [DllImport(&quot;kernel32.dll&quot;)] public static extern void SetLastError(uint dwErrCode); [DllImport(&quot;user32&quot;)] public static extern int GetClassName(IntPtr hWnd, StringBuilder lpString, int nMaxCount); [DllImport(&quot;user32&quot;)] public static extern bool IsWindowVisible(IntPtr hWnd); [DllImport(&quot;user32.dll&quot;)] public static extern int GetWindowRect(IntPtr hwnd, out Rect lpRect); public static IntPtr ptrWnd = IntPtr.Zero; static string Title; /// &lt;summary&gt; /// 获得当前进程的主窗口句柄 /// &lt;/summary&gt; /// &lt;param name=&quot;title&quot;&gt;窗口标题&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static IntPtr GetProcessWnd(string title) &#123; if (ptrWnd == IntPtr.Zero) &#123; Title = title; uint pid = (uint)Process.GetCurrentProcess().Id; // 当前进程 ID bool bResult = EnumWindows(OnWindowEnum, pid); return (!bResult &amp;&amp; Marshal.GetLastWin32Error() == 0) ? ptrWnd : IntPtr.Zero; &#125; return ptrWnd; &#125; static bool OnWindowEnum(IntPtr hwnd, int lParam) &#123; uint id = 0; if (GetParent(hwnd) == IntPtr.Zero) &#123; GetWindowThreadProcessId(hwnd, ref id); if (id == lParam) // 找到进程对应的主窗口句柄 &#123; int length = GetWindowTextLength(hwnd); StringBuilder windowName = new StringBuilder(length + 1); GetWindowText(hwnd, windowName, windowName.Capacity); if (windowName.ToString().CompareTo(Title) == 0) &#123; ptrWnd = hwnd; // 把句柄缓存起来 SetLastError(0); // 设置无错误 return false; // 返回 false 以终止枚举窗口 &#125; &#125; &#125; return true; &#125; public static bool IsCover(IntPtr handle) &#123; var currentWindow = GetWindowDetail(handle); var windows = GetAllAboveWindows(handle); var windowInfos = windows.Where(I =&gt; I.IsVisible &amp;&amp; !I.IsMinimized &amp;&amp; I.Bounds.Width &gt; 1 &amp;&amp; I.Bounds.Height &gt; 1 &amp;&amp; I.Hwnd != handle &amp;&amp; !(I.ClassName.StartsWith(&quot;Shell_&quot;) &amp;&amp; I.ClassName.EndsWith(&quot;TrayWnd&quot;))) .ToList(); foreach (var item in windowInfos) &#123; if (item.Bounds.Contains(currentWindow.Bounds)) return true; &#125; return false; &#125; /// &lt;summary&gt; /// 查找当前用户空间下所有符合条件的窗口（仅查找顶层窗口）。如果不指定条件，将返回所有窗口。 /// &lt;/summary&gt; /// &lt;param name=&quot;match&quot;&gt;过滤窗口的条件。&lt;/param&gt; /// &lt;returns&gt;找到的所有窗口信息。&lt;/returns&gt; public static IReadOnlyList&lt;WindowInfo&gt; FindAll(Predicate&lt;WindowInfo&gt; match = null) &#123; var windowList = new List&lt;WindowInfo&gt;(); EnumWindows(OnWindowEnum, 0); return match == null ? windowList : windowList.FindAll(match); bool OnWindowEnum(IntPtr hWnd, int lparam) &#123; // 仅查找顶层窗口。 if (GetParent(hWnd) == IntPtr.Zero) &#123; var windowDetail = GetWindowDetail(hWnd); // 添加到已找到的窗口列表。 windowList.Add(windowDetail); &#125; return true; &#125; &#125; public static WindowInfo GetWindowDetail(IntPtr hWnd) &#123; // 获取窗口类名。 var lpString = new StringBuilder(512); GetClassName(hWnd, lpString, lpString.Capacity); var className = lpString.ToString(); // 获取窗口标题。 var lptrString = new StringBuilder(512); GetWindowText(hWnd, lptrString, lptrString.Capacity); var title = lptrString.ToString().Trim(); // 获取窗口可见性。 var isVisible = IsWindowVisible(hWnd); // 获取窗口位置和尺寸。 Rect rect = default; GetWindowRect(hWnd, out rect); var bounds = new Rectangle(rect.Left, rect.Top, rect.Right - rect.Left, rect.Bottom - rect.Top); return new WindowInfo(hWnd, className, title, isVisible, bounds); &#125; public static List&lt;WindowInfo&gt; GetAllAboveWindows(IntPtr hwnd) &#123; var windowInfos = new List&lt;WindowInfo&gt;(); var intPtr = GetWindow(hwnd, 3); if (intPtr == IntPtr.Zero) &#123; return windowInfos; &#125; var windowDetail = GetWindowDetail(intPtr); windowInfos.AddRange(GetAllAboveWindows(intPtr)); windowInfos.Add(windowDetail); return windowInfos; &#125; public static List&lt;WindowInfo&gt; GetAllBelowWindows(IntPtr hwnd) &#123; var windowInfos = new List&lt;WindowInfo&gt;(); var intPtr = GetWindow(hwnd, 2); if (intPtr == IntPtr.Zero) &#123; return windowInfos; &#125; var windowDetail = GetWindowDetail(intPtr); windowInfos.AddRange(GetAllBelowWindows(intPtr)); windowInfos.Add(windowDetail); return windowInfos; &#125;&#125;","tags":["unity","窗口遮挡","Win32"]}]