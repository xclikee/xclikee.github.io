[{"title":"ASP.NET WebAPi之断点续传下载（中）","path":"/2025/03/26/ASP-NET-WebAPi之断点续传下载（中）/","content":"前言前情回顾：上一篇我们遗留了两个问题，一个是未完全实现断点续传，另外则是在响应时是返回StreamContent还是PushStreamContent呢？这一节我们重点来解决这两个问题，同时就在此过程中需要注意的地方一并指出，若有错误之处，请指出。 StreamContent compare to PushStreamContent我们来看看StreamContent代码，如下： 123456789101112131415161718192021222324252627public class StreamContent : HttpContent&#123; // Fields private int bufferSize; private Stream content; private bool contentConsumed; private const int defaultBufferSize = 0x1000; private long start; // Methods public StreamContent(Stream content); public StreamContent(Stream content, int bufferSize); protected override Task&lt;Stream&gt; CreateContentReadStreamAsync(); protected override void Dispose(bool disposing); private void PrepareContent(); protected override Task SerializeToStreamAsync(Stream stream, TransportContext context); protected internal override bool TryComputeLength(out long length); // Nested Types private class ReadOnlyStream : DelegatingStream &#123;......&#125;&#125; 似乎没有什么可看的，但是有一句话我们需要注意，如下： private const int defaultBufferSize = 0x1000; 在StreamContent的第二个构造函数为 public StreamContent(Stream content, int bufferSize); 上述给定的默认一次性输入到缓冲区大小为4k，这对我们有何意义呢？当我们写入到响应中时，一般我们直接利用的是第一个构造函数，如下： 12var response = new HttpResponseMessage();response.Content \\= new StreamContent(fileStream); 到这里我们明白了这么做是有问题的，当下载时默认读取的是4k，如果文件比较大下载的时间则有延长，所以我们在返回时一定要给定缓冲大小，那么给定多少呢？为达到更好的性能最多是80k，如下： 12private const int BufferSize = 80 \\* 1024;response.Content \\= new StreamContent(fileStream, BufferSize); 此时下载的速度则有很大的改善，有人就说了为何是80k呢？这个问题我也不知道，老外验证过的，这是链接【.NET Asynchronous stream read&#x2F;write】。 好了说完StreamContent，接下来我们来看看PushStreamContent，从字面意思来为推送流内容，难道是充分利用了缓冲区吗，猜测可以有，就怕没有任何想法，我们用源码来证明看看。 我们只需看看WebHost模式下对于缓冲策略是怎么选择的，我们看看此类 WebHostBufferPolicySelector 实现，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738 /// &lt;summary&gt;/// Provides an implementation of &lt;see cref=&quot;IHostBufferPolicySelector&quot;/&gt; suited for use/// in an ASP.NET environment which provides direct support for input and output buffering./// &lt;/summary&gt;public class WebHostBufferPolicySelector : IHostBufferPolicySelector&#123; ....../// &lt;summary&gt; /// Determines whether the host should buffer the &lt;see cref=&quot;HttpResponseMessage&quot;/&gt; entity body. /// &lt;/summary&gt; /// &lt;param name=&quot;response&quot;&gt;The &lt;see cref=&quot;HttpResponseMessage&quot;/&gt;response for which to determine /// whether host output buffering should be used for the response entity body.&lt;/param&gt; /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if buffering should be used; otherwise a streamed response should be used.&lt;/returns&gt; public virtual bool UseBufferedOutputStream(HttpResponseMessage response) &#123; if (response == null) &#123; throw Error.ArgumentNull(&quot;response&quot;); &#125; // Any HttpContent that knows its length is presumably already buffered internally. HttpContent content = response.Content; if (content != null) &#123; long? contentLength = content.Headers.ContentLength; if (contentLength.HasValue &amp;&amp; contentLength.Value &gt;= 0) &#123; return false; &#125; // Content length is null or -1 (meaning not known). // Buffer any HttpContent except StreamContent and PushStreamContent return !(content is StreamContent || content is PushStreamContent); &#125; return false; &#125;&#125; 从上述如下一句可以很明显的知道： return !(content is StreamContent || content is PushStreamContent); 除了StreamContent和PushStreamContent的HttpContent之外，其余都进行缓冲，所以二者的区别不在于缓冲，那到底是什么呢？好了我们还未查看PushStreamContent的源码，我们继续往下走，查看其源代码如下，我们仅仅只看关于这个类的描述以及第一个构造函数即可，如下： 12345678910111213141516171819202122232425/// &lt;summary&gt; /// Provides an &lt;see cref=&quot;HttpContent&quot;/&gt; implementation that exposes an output &lt;see cref=&quot;Stream&quot;/&gt; /// which can be written to directly. The ability to push data to the output stream differs from the /// &lt;see cref=&quot;StreamContent&quot;/&gt; where data is pulled and not pushed. /// &lt;/summary&gt; public class PushStreamContent : HttpContent &#123; private readonly Func&lt;Stream, HttpContent, TransportContext, Task&gt; \\_onStreamAvailable; /// &lt;summary&gt; /// Initializes a new instance of the &lt;see cref=&quot;PushStreamContent&quot;/&gt; class. The /// &lt;paramref name=&quot;onStreamAvailable&quot;/&gt; action is called when an output stream /// has become available allowing the action to write to it directly. When the /// stream is closed, it will signal to the content that is has completed and the /// HTTP request or response will be completed. /// &lt;/summary&gt; /// &lt;param name=&quot;onStreamAvailable&quot;&gt;The action to call when an output stream is available.&lt;/param&gt; public PushStreamContent(Action&lt;Stream, HttpContent, TransportContext&gt; onStreamAvailable) : this(Taskify(onStreamAvailable), (MediaTypeHeaderValue)null) &#123; &#125; ...... &#125; 对于此类的描述大意是：PushStreamContent与StreamContent的不同在于，PushStreamContent在于将数据push【推送】到输出流中，而StreamContent则是将数据从流中【拉取】。 貌似有点晦涩，我们来举个例子，在webapi中我们常常这样做，读取文件流并返回到响应流中，若是StreamContent，我们会如下这样做： response.Content = new StreamContent(File.OpenRead(filePath)); 上面的释义我用大括号着重括起，StreamContent着重于【拉取】，当响应时此时将从文件流写到输出流，通俗一点说则是我们需要从文件流中去获取数据并写入到输出流中。我们再来看看PushStreamContent的用法，如下： 123456789XDocument xDoc = XDocument.Load(&quot;cnblogs\\_backup.xml&quot;, LoadOptions.None);PushStreamContent xDocContent \\= new PushStreamContent((stream, content, context) \\=&gt;&#123; xDoc.Save(stream); stream.Close();&#125;,&quot;application/xml&quot;); PushStreamContent着重于【推送】，当我们加载xml文件时，当我们一旦进行保存时此时则会将数据推送到输出流中。 二者区别在于：StreamContent从流中【拉取】数据，而PushStreamContent则是将数据【推送】到流中。 那么此二者应用的场景是什么呢？（1）对于下载文件我们则可以通过StreamContent来实现直接从流中拉取，若下载视频流此时则应该利用PushStreamContent来实现，因为未知服务器视频资源的长度，此视频资源来源于别的地方。 （2）数据量巨大，发送请求到webapi时利用PushStreamContent。 当发送请求时，常常序列化数据并请求webapi，我们可能这样做： 123var client = new HttpClient();string json = JsonConvert.SerializeObject(data);var response = await client.PostAsync(uri, new StringContent(json)); 当数据量比较小时没问题，若数据比较大时进行序列化此时则将序列化的字符串加载到内存中，鉴于此这么做不可行，此时我们应该利用PushStreamContent来实现。 123456789101112var client = new HttpClient();var content = new PushStreamContent((stream, httpContent, transportContext) =&gt;&#123; var serializer = new JsonSerializer(); using (var writer = new StreamWriter(stream)) &#123; serializer.Serialize(writer, data); &#125;&#125;);var response = await client.PostAsync(uri, content); 为什么要这样做呢？我们再来看看源码，里面存在这样一个方法。 protected override Task SerializeToStreamAsync(Stream stream, TransportContext context); 其内部实现利用异步状态机实现，所以当数据量巨大时利用PushStreamContent来返回将会有很大的改善，至此，关于二者的区别以及常见的应用场景已经叙述完毕，接下来我们继续断点续传问题。 断点续传改进 上一篇我们讲过获取Range属性中的集合通过如下： request.Headers.Range 我们只取该集合中的第一个范围元素，通过如下 RangeItemHeaderValue range = rangeHeader.Ranges.First(); 此时我们忽略了返回的该范围对象中有当前下载的进度 12range.From.HasValue range.To.HasValue 我们获取二者的值然后进行重写Stream实时读取剩余部分，下面我们一步一步来看。 定义文件操作接口12345678public interface IFileProvider&#123; bool Exists(string name); FileStream Open(string name); long GetLength(string name);&#125; 实现该操作文件接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class FileProvider : IFileProvider&#123; private readonly string \\_filesDirectory; private const string AppSettingsKey = &quot;DownloadDir&quot;; public FileProvider() &#123; var fileLocation = ConfigurationManager.AppSettings\\[AppSettingsKey\\]; if (!String.IsNullOrWhiteSpace(fileLocation)) &#123; \\_filesDirectory \\= fileLocation; &#125; &#125; /// &lt;summary&gt; /// 判断文件是否存在 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool Exists(string name) &#123; string file = Directory.GetFiles(\\_filesDirectory, name, SearchOption.TopDirectoryOnly) .FirstOrDefault(); return true; &#125; /// &lt;summary&gt; /// 打开文件 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public FileStream Open(string name) &#123; var fullFilePath = Path.Combine(\\_filesDirectory, name); return File.Open(fullFilePath, FileMode.Open, FileAccess.Read, FileShare.Read); &#125; /// &lt;summary&gt; /// 获取文件长度 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public long GetLength(string name) &#123; var fullFilePath = Path.Combine(\\_filesDirectory, name); return new FileInfo(fullFilePath).Length; &#125;&#125; 获取范围对象中的值进行赋值给封装的对象12345678public class FileInfo&#123; public long From; public long To; public bool IsPartial; public long Length;&#125; 下载控制器，对文件操作进行初始化123456789101112public class FileDownloadController : ApiController&#123; private const int BufferSize = 80 \\* 1024; private const string MimeType = &quot;application/octet-stream&quot;; public IFileProvider FileProvider &#123; get; set; &#125; public FileDownloadController() &#123; FileProvider \\= new FileProvider(); &#125; ......&#125; 接下来则是文件下载的逻辑，首先判断请求文件是否存在，然后获取文件的长度 123456if (!FileProvider.Exists(fileName))&#123; throw new HttpResponseException(HttpStatusCode.NotFound);&#125;long fileLength = FileProvider.GetLength(fileName); 将请求中的范围对象From和To的值并判断当前已经下载进度以及剩余进度1234567891011121314151617181920212223242526272829303132333435363738394041424344private FileInfo GetFileInfoFromRequest(HttpRequestMessage request, long entityLength)&#123; var fileInfo = new FileInfo &#123; From \\= 0, To \\= entityLength - 1, IsPartial \\= false, Length \\= entityLength &#125;; var rangeHeader = request.Headers.Range; if (rangeHeader != null &amp;&amp; rangeHeader.Ranges.Count != 0) &#123; if (rangeHeader.Ranges.Count &gt; 1) &#123; throw new HttpResponseException(HttpStatusCode.RequestedRangeNotSatisfiable); &#125; RangeItemHeaderValue range \\= rangeHeader.Ranges.First(); if (range.From.HasValue &amp;&amp; range.From &lt; 0 || range.To.HasValue &amp;&amp; range.To &gt; entityLength - 1) &#123; throw new HttpResponseException(HttpStatusCode.RequestedRangeNotSatisfiable); &#125; fileInfo.From \\= range.From ?? 0; fileInfo.To \\= range.To ?? entityLength - 1; fileInfo.IsPartial \\= true; fileInfo.Length \\= entityLength; if (range.From.HasValue &amp;&amp; range.To.HasValue) &#123; fileInfo.Length \\= range.To.Value - range.From.Value + 1; &#125; else if (range.From.HasValue) &#123; fileInfo.Length \\= entityLength - range.From.Value + 1; &#125; else if (range.To.HasValue) &#123; fileInfo.Length \\= range.To.Value + 1; &#125; &#125; return fileInfo;&#125; 在响应头信息中的对象ContentRangeHeaderValue设置当前下载进度以及其他响应信息123456789101112131415161718private void SetResponseHeaders(HttpResponseMessage response, FileInfo fileInfo, long fileLength, string fileName) &#123; response.Headers.AcceptRanges.Add(&quot;bytes&quot;); response.StatusCode \\= fileInfo.IsPartial ? HttpStatusCode.PartialContent : HttpStatusCode.OK; response.Content.Headers.ContentDisposition \\= new ContentDispositionHeaderValue(&quot;attachment&quot;); response.Content.Headers.ContentDisposition.FileName \\= fileName; response.Content.Headers.ContentType \\= new MediaTypeHeaderValue(MimeType); response.Content.Headers.ContentLength \\= fileInfo.Length; if (fileInfo.IsPartial) &#123; response.Content.Headers.ContentRange \\= new ContentRangeHeaderValue(fileInfo.From, fileInfo.To, fileLength); &#125; &#125; 最重要的一步则是将FileInfo对象的值传递给我们自定义实现的流监控当前下载进度。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class PartialContentFileStream : Stream&#123; private readonly long \\_start; private readonly long \\_end; private long \\_position; private FileStream \\_fileStream; public PartialContentFileStream(FileStream fileStream, long start, long end) &#123; \\_start \\= start; \\_position \\= start; \\_end \\= end; \\_fileStream \\= fileStream; if (start &gt; 0) &#123; \\_fileStream.Seek(start, SeekOrigin.Begin); &#125; &#125; /// &lt;summary&gt; /// 将缓冲区数据写到文件 /// &lt;/summary&gt; public override void Flush() &#123; \\_fileStream.Flush(); &#125; /// &lt;summary&gt; /// 设置当前下载位置 /// &lt;/summary&gt; /// &lt;param name=&quot;offset&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;origin&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public override long Seek(long offset, SeekOrigin origin) &#123; if (origin == SeekOrigin.Begin) &#123; \\_position \\= \\_start + offset; return \\_fileStream.Seek(\\_start + offset, origin); &#125; else if (origin == SeekOrigin.Current) &#123; \\_position += offset; return \\_fileStream.Seek(\\_position + offset, origin); &#125; else &#123; throw new NotImplementedException(&quot;SeekOrigin.End未实现&quot;); &#125; &#125; /// &lt;summary&gt; /// 依据偏离位置读取 /// &lt;/summary&gt; /// &lt;param name=&quot;buffer&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;offset&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;count&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public override int Read(byte\\[\\] buffer, int offset, int count) &#123; int byteCountToRead = count; if (\\_position + count &gt; \\_end) &#123; byteCountToRead \\= (int)(\\_end - \\_position) + 1; &#125; var result = \\_fileStream.Read(buffer, offset, byteCountToRead); \\_position += byteCountToRead; return result; &#125; public override IAsyncResult BeginRead(byte\\[\\] buffer, int offset, int count, AsyncCallback callback, object state) &#123; int byteCountToRead = count; if (\\_position + count &gt; \\_end) &#123; byteCountToRead \\= (int)(\\_end - \\_position); &#125; var result = \\_fileStream.BeginRead(buffer, offset, count, (s) \\=&gt; &#123; \\_position += byteCountToRead; callback(s); &#125;, state); return result; &#125; ......&#125; 更新上述下载的完整逻辑123456789101112131415161718public HttpResponseMessage GetFile(string fileName)&#123; fileName \\= &quot;HBuilder.windows.5.2.6.zip&quot;; if (!FileProvider.Exists(fileName)) &#123; throw new HttpResponseException(HttpStatusCode.NotFound); &#125; long fileLength = FileProvider.GetLength(fileName); var fileInfo = GetFileInfoFromRequest(this.Request, fileLength); var stream = new PartialContentFileStream(FileProvider.Open(fileName), fileInfo.From, fileInfo.To); var response = new HttpResponseMessage(); response.Content \\= new StreamContent(stream, BufferSize); SetResponseHeaders(response, fileInfo, fileLength, fileName); return response;&#125; 下面我们来看看演示结果： 好了，到了这里我们也得到了我们想要的结果。 总结 本节我们将上节遗留的问题一一进行比较详细的叙述并最终解决，是不是就这么完全结束了呢？那本节定义为中篇岂不是不对头了，本节是在web端进行下载，下节我们利用webclient来进行断点续传。想了想无论是mvc上传下载，还是利用webapi来上传下载又或者是将mvc和webapi结合来上传下载基本都已经囊括，这都算是在项目中比较常用的吧，所以也就花了很多时间去研究。对于webapi的断点续传关键它本身就提供了比较多的api来给我们调用，所以还是很不错，webapi一个很轻量的服务框架，你值得拥有see u，反正周末，哟，不早了，休息休息。 本文转自 https://www.cnblogs.com/CreateMyself/p/6078052.html，如有侵权，请联系删除。"},{"title":"ASP.NET WebAPi之断点续传下载（上）","path":"/2025/03/26/ASP-NET-WebAPi之断点续传下载（上）/","content":"前言之前一直感觉断点续传比较神秘，于是想去一探究竟，不知从何入手，以为就写写逻辑就行，结果搜索一番，还得了解相关http协议知识，又花了许久功夫去看http协议中有关断点续传知识，有时候发觉东西只有当你用到再去看相关内容时才会掌握的更加牢固，理解的更加透彻吧，下面我们首先来补补关于http协议中断点续传的知识。 http协议知识恶补当请求一个html页面时我们会看到请求页面如下： 第一眼看到上面Accept中的参数时我是懵逼的，之前也就看看缓存cookie等常见的头信息，于是借此机会也学习下这部分内容。 我们知道Accept是指客户端允许请求返回的内容类型，那为何这里面参数有如此之多呢？在学习WebAPi时，我们在服务端未进行过滤时既可以返回xml，也可以返回json，此时如上图一样，text&#x2F;html未匹配上，接着匹配xml类型，匹配后则进行相应格式内容返回，所以客户端接受如此多类型内容，也是为了服务端那边未设置特定内容响应，此时则根据客户端设置的内容进行最合适的匹配。 那么问题来了，上面的q是啥玩意？ q（quality）上面给出了客户端能够接受响应的内容类型，自然就有最合适的匹配，此时就用到了q这个参数，在此我将q翻译为quality即权重的意思，应该是比较合适的，它用来表示我们期待接受内容偏爱的程度即所占的权重。它的范围是0-1，其默认值为1，这就类似质检部门对产品合格判断的一种介质。例如当我们需要返回视频资源时，我们客户端设置为如下： Accept: audio/\\*; q=0.2, audio/basic 此时我们将上述翻译如下： 12audio/basic; q=1audio/\\*; q=0.2 我们更加期待返回的是audio&#x2F;basic类型的资源，因为其权重为1大于audio&#x2F;*类型的资源，若为匹配到则继续匹配下一个资源，audio&#x2F;*则表示属于audio类型的所有子类型资源。 接下来，我们再来看一个例子： Accept: text/plain; q=0.5, text/html,text/x-dvi; q=0.8, text/x-c 此时我们则可以翻译为如下： 1234Accept: text/html;q=1或者 text/x-c;q=1text/x-dvi; q=0.8text/plain; q=0.5 倾向于返回text&#x2F;html或者text&#x2F;x-c类型资源，若都不存在，则返回权重为0.8的text&#x2F;x-dvi，最终还是不存在则返回text&#x2F;plain。 Accept-Ranges在响应头中添加此字段允许服务端来显示表明对资源范围的接受。如果服务端接受一个字节范围的资源的请求则此时变成如下： Accept-Ranges: bytes 如果服务端不接受任何范围的请求资源此时则在响应头添加如下来告诉客户端不要发送范围请求的资源： Accept-Ranges: none Content-Range当在响应头中添加接受字节范围的资源时，此时若客户端请求资源文件比较大时即只是返回部分数据时，此时则返回状态码为206的部分内容，在Content-Range响应头信息中实时显示当前数据的进度。比如如下： 1234567891011//开始500个字节数据Content-Range: bytes 0\\-499/1234//第二个500个字节数据Content-Range: bytes 500\\-999/1234//除了开始500个字节之外的数据Content-Range: bytes 500\\-1233/1234//最后500个字节数据（表示数据最终传输完毕）Content-Range: bytes 734\\-1233/1234 如果客户端请求资源到达所给资源的界限此时则返回416的状态码。 注意：当请求资源为字节范围请求时，不要在响应头中使用 multipart&#x2F;byteranges 类型的content-type。 断点续传场景当正在下载时出于其他任何原因此时下载中断，那么下载用户只能重新下载，这样的体验想必是比较痛苦的，最烦躁的是如果用户是在移动端下载大文件时，居然下载中断了，接下来又得重新下载，此时想必用户会放弃下载。此时断点续传则应运而生。 断点续传则需要用到上述Accept-Ranges和Content-Range将其添加到响应头中。例如如下： 12345678910HEAD http://localhost/api/files/get?filename=blog\\_backup.zip User-Agent: IISHost: localhostHTTP/1.1 200 OK Content\\-Length: 1182367743 Content\\-Type: application/octet-stream Accept\\-Ranges: bytes Server: Microsoft\\-IIS/10.0 Content\\-Disposition: attachment; filename=blog\\_backup.zip 123456789101112HEAD http://localhost/api/files/get?filename=blog\\_backup.zip User-Agent: IISHost: localhost Range: bytes\\=0\\-999HTTP/1.1 206 Partial Content Content\\-Length: 1000 Content\\-Type: application/octet-stream Content\\-Range: bytes 0\\-999/1182367743 Accept\\-Ranges: bytes Server: Microsoft\\-IIS/10.0 Content\\-Disposition: attachment; filename=blog\\_backup.zip 接下来我们来实现简单的下载以及断点续传下载对比看看效果。 在webapi中提供了一系列方便我们调用的api，比如 ContentDispositionHeaderValue 来设置附件而不像在webform中手动在响应头中进行拼接。以及返回的MimeType类型 MediaTypeHeaderValue 。首先我们看看最普通的下载。 普通下载普通的下载无非就是获取到文件的标识再打开下载的文件夹，最后得到文件流返回到响应的HttpContent对象中以及设置附件即可。我们看看如下代码还是比较简单的，这种相对比较简单的下载想必我们大家定是信手拈来。 //响应的MimeType类型 private const string MimeType = &quot;application/octet-stream&quot;; //配置文件中配置的文件所在路径 private const string AppSettingDirPath = &quot;DownloadDir&quot;; //将配置文件中取得的路径赋给此变量 private readonly string DirFilePath; this.DirFilePath = ConfigurationManager.AppSettings\\[AppSettingDirPath\\]; 接下来就是最重要的下载逻辑了，如下： public HttpResponseMessage Download(string fileName) &#123; var fullFilePath = Path.Combine(this.DirFilePath, fileName); if (!File.Exists(fullFilePath)) &#123; throw new HttpResponseException(HttpStatusCode.NotFound); &#125; FileStream fileStream \\= File.Open(fullFilePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite); var response = new HttpResponseMessage(); response.Content \\= new StreamContent(fileStream); response.Content.Headers.ContentDisposition \\= new ContentDispositionHeaderValue(&quot;attachment&quot;) &#123; FileName = fileName &#125;; response.Content.Headers.ContentType \\= new MediaTypeHeaderValue(MimeType); response.Content.Headers.ContentLength \\= fileStream.Length; return response; &#125; 那么问题来了，我们可不可以在获取文件流返回到HttpContent之前是不是应该首先将文件流放入到缓冲流中然后再返回呢？如下： 12var bufferStream = new BufferedStream(fileStream);response.Content \\= new StreamContent(bufferStream); 我们想着是不是将文件流率先放入到缓冲流中效果是否更佳呢？刚开始我也是这样想来着，但是经过查证资料发现: 为了得到更好的性能，在文件流中已经包含有缓冲流的缓冲逻辑，对于用缓冲流来包裹文件流的情况没有任何好处，还有一点就是在.NET Framework中没有任何一个流需要用到缓冲流，但是，但是有一种情况除外则是若我们自定义实现流且默认没有实现缓冲的逻辑情况下需要用到缓冲流，资料来源于：Filestream and BufferedStream 上述也算是涨知识了。继续回到我们的话题，此时我们下载一个文件则看到如下图所示： 因为未实现断点续传，此时我们通过右键可以看到无法暂停，如下： 我们继续往下走，接下来来实现断点续传看看： 断点续传下载在WebAPi提供了Range属性其返回对象为 RangeHeaderValue 里面有存在每个范围的集合如下： 12345678910// 摘要: // Gets the ranges specified from the System.Net.Http.Headers.RangeHeaderValue// object.//// 返回结果: // Returns System.Collections.Generic.ICollection&lt;T&gt;.The ranges from the System.Net.Http.Headers.RangeHeaderValue// object.public ICollection&lt;RangeItemHeaderValue&gt; Ranges &#123; get; &#125; 这是为利用多线程下载而提供，这里我们仅仅实现一个范围的下载。我们通过判断这个对象的值是否为null来实现断点续传。 12345678910111213141516if (Request.Headers.Range == null || Request.Headers.Range.Ranges.Count \\== 0 || Request.Headers.Range.Ranges.FirstOrDefault().From.Value \\== 0)&#123; var sourceStream = File.Open(fullFilePath, FileMode.Open, FileAccess.Read, FileShare.Read); response \\= new HttpResponseMessage(HttpStatusCode.OK); response.Content \\= new StreamContent(sourceStream); response.Headers.AcceptRanges.Add(&quot;bytes&quot;);//告诉客户端接受资源为字节 response.Content.Headers.ContentLength \\= sourceStream.Length; response.Content.Headers.ContentType \\= new MediaTypeHeaderValue(MimeType); response.Content.Headers.ContentDisposition \\= new ContentDispositionHeaderValue(&quot;attachment&quot;) &#123; FileName \\= fileName &#125;;&#125; 获取当前已经下载字节数，接着继续进行剩下字节下载。 123456789else&#123; var item = Request.Headers.Range.Ranges.FirstOrDefault(); if (item != null &amp;&amp; item.From.HasValue) &#123; response \\= this.GetPartialContent(fileName, item.From.Value); &#125;&#125; 剩余字节数下载 12345678910111213141516171819202122232425262728293031323334private HttpResponseMessage GetPartialContent(string fileName, long partial)&#123; var response = new HttpResponseMessage(); var fullFilePath = Path.Combine(this.DirFilePath, fileName); FileInfo fileInfo \\= new FileInfo(fullFilePath); long startByte = partial; var memoryStream = new MemoryStream(); var buffer = new byte\\[65536\\]; using (var fileStream = File.Open(fullFilePath, FileMode.Open, FileAccess.Read, FileShare.Read)) &#123; var bytesRead = 0; fileStream.Seek(startByte, SeekOrigin.Begin); int length = Convert.ToInt32((fileInfo.Length - 1) - startByte) + 1; while (length &gt; 0 &amp;&amp; bytesRead &gt; 0) &#123; bytesRead \\= fileStream.Read(buffer, 0, Math.Min(length, buffer.Length)); memoryStream.Write(buffer, 0, bytesRead); length \\-= bytesRead; &#125; response.Content \\= new StreamContent(memoryStream); &#125; response.Headers.AcceptRanges.Add(&quot;bytes&quot;); response.StatusCode \\= HttpStatusCode.PartialContent; response.Content.Headers.ContentType \\= new MediaTypeHeaderValue(MimeType); response.Content.Headers.ContentLength \\= File.Open(fullFilePath, FileMode.Open, FileAccess.Read, FileShare.Read).Length; response.Content.Headers.ContentDisposition \\= new ContentDispositionHeaderValue(&quot;attachment&quot;) &#123; FileName \\= fileName &#125;; return response;&#125; 接下来我们看看演示结果： 从上面演示我们看出目前已经实现了断点续传，浏览器下载管理器出现了暂停的按钮，但是当暂停后无法继续进行后续下载，在这里存在问题，我们下节再进行后续讲解。同时当返回HttpContent发现居然还有一个可以返回的HttpContent即 PushStreamContent ，此时我们可以将剩余部分字节下载进行如下修改： 1234567891011121314151617181920212223242526272829303132333435363738394041 Action&lt;Stream, HttpContent, TransportContext&gt; pushContentAction = (outputStream, content, context) =&gt; &#123; try &#123; var buffer = new byte\\[65536\\]; using (var fileStream = File.Open(fullFilePath, FileMode.Open, FileAccess.Read, FileShare.Read)) &#123; var bytesRead = 0; fileStream.Seek(startByte, SeekOrigin.Begin); int length = Convert.ToInt32((fileInfo.Length - 1) - startByte) + 1; while (length &gt; 0 &amp;&amp; bytesRead &gt; 0) &#123; bytesRead \\= fileStream.Read(buffer, 0, Math.Min(length, buffer.Length)); outputStream.Write(buffer, 0, bytesRead); length \\-= bytesRead; &#125; &#125; &#125; catch (HttpException ex) &#123; throw ex; &#125; finally &#123; outputStream.Close(); &#125; &#125;;response.Content \\= new PushStreamContent(pushContentAction, new MediaTypeHeaderValue(MimeType)); response.StatusCode \\= HttpStatusCode.PartialContent; response.Headers.AcceptRanges.Add(&quot;bytes&quot;); response.Content.Headers.ContentType \\= new MediaTypeHeaderValue(MimeType); response.Content.Headers.ContentLength \\= File.Open(fullFilePath, FileMode.Open, FileAccess.Read, FileShare.Read).Length; response.Content.Headers.ContentDisposition \\= new ContentDispositionHeaderValue(&quot;attachment&quot;) &#123; FileName \\= fileName &#125;; return response; 如上所做也可行，返回StreamContent不就ok了吗，为何还出现一个PushStreamContent呢？这又是一个遗留问题！ 总结本节我们讲述了在webapi中普通下载以及断点续传下载，对于断点续传下载当暂停后无法继续进行下载，暂时还存在一定问题，对于返回的内容既可以为StreamContent，也可以是PushStreamContent，这二者有何区别呢？二者的应用场景是什么呢？这又是一个问题，关于此二者我们下节再讲，webapi一个很轻量的服务框架，你值得拥有，see u。 本文转自 https://www.cnblogs.com/CreateMyself/p/6063646.html，如有侵权，请联系删除。"},{"title":"Unity实现UI的边缘检测和拖拽拉伸功能","path":"/2025/03/24/Unity实现UI的边缘检测和拖拽拉伸功能/","content":"一、功能需求分析最近赶项目，许久没写博客了。今天忙里偷闲，记录一下最近项目里遇到的一个功能——拖拽UI窗口边缘拉伸其大小，基本上现在的PC端的软件窗口都有这个功能。该功能效果就是需要做成跟Unity工具栏中的矩形工具的功能一样，当鼠标光标移入UI的各个边缘区域时显示不同的鼠标光标，并按下鼠标往不同方向拖拽拉伸时能实时调整该UI的大小。所以总结了以下两点需求： 鼠标移入UI时作边缘检测算法，获取该边缘类型的标识。 根据边缘类型，在拖拽时动态调整该UI大小。 ##三、实现原理 UI边缘检测算法原理我们都知道可以使用RectTransformUtility.RectangleContainsScreenPoint方法来判断鼠标位置是否在一个UI矩形区域内，那如何判断鼠标是否在UI的上下左右边缘区域或者四个边缘角的位置呢？刚开始我也是百思不得其解，后来才逐渐摸索出来解决方法。我们这里也是需要小小的使用到分治思想——那就是“分而治之”，将复杂问题拆分成诺干个相同的小问题进行解决。即： 原文Unity实现UI的边缘检测和拖拽拉伸功能","tags":["UI"],"categories":["Unity"]},{"title":"SpeechLib 文字转语音","path":"/2025/03/24/SpeechLib-文字转语音/","content":"什么是SAPI?软件中的语音技术主要包括两方面的内容，一个是语音识别(speech recognition) ，另外一个是语音合成(speech synthesis)，也即是文本语音转换系统(TTS)。TTS系统使用合成语音合成文本字符串和文件到声音音频流。而语音识别系统则是转换人类的声音语音流到可读的文本字符串或者文件。这两个工作，都是通过各种语音引擎来完成的。微软所提供的SAPI (全称The Microsoft Speech API)，正是在应用程序和语音引擎之间提供一个高级别的接口，它实现了所有必需的对各种语音引擎的实时的控制和管理等低级别的细节。语音引擎通过DDI层(设备驱动接口)和SAPI进行交互，应用程序通过API层和SAPI通信。通过使用这些API，我们可以快速开发在语音识别或语音合成方面应用程序。SAPI 应用程序编程接口(API)明显的减少了构建一个使用语音识别和文本语音转换的应用程序所需要的高层代码，使语音技术更加容易使用并且更加扩大了应用的范围。虽然现在SAPI不是业界标准，但he是应用非常广泛。 SAPI包括以下组件对象(接口)： Voice Commands API 对应用程序进行控制，一般用于语音识别系统中。识别某个命令后，会调用相关接口是应用程序完成对应的功能。如果程序想实现语音控制，必须使用此组对象。 Voice Dictation API 听写输入，即语音识别接口。 Voice Text API 完成从文字到语音的转换，即语音合成。 Voice Telephone API 语音识别和语音合成综合运用到电话系统之上，利用此接口可以建立一个电话应答系统，甚至可以通过电话控制计算机。 Audio Objects API 封装了计算机发音系统。 其中Voice Text API，就是微软TTS引擎的接口，通过它我们可以很容易地建立功能强大的文本语音程序，金山词霸的单词朗读功能就用到了这些API，而目前几乎所有的文本朗读工具都是用SAPI开发的。在这里，我们使用的主要就是Voice Text API。 SAPI SDK 下载 目前已经无法访问 unity 使用代码 需要引用库 Interop.SpeechLib unity代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879using SpeechLib;using UnityEngine;namespace XC&#123; public class SpeechControll : MonoBehaviour &#123; private static SpeechControll _instance; public static SpeechControll Ins &#123; get &#123; if (null == _instance) &#123; GameObject go = new GameObject(&quot;[SpeechControll]&quot;); _instance = go.AddComponent&lt;SpeechControll&gt;(); _instance.Init(); &#125; return _instance; &#125; &#125; SpVoice _voice; void Init() &#123; //实例化 SpVoice 对象 _voice = new SpVoice(); //管理语音属性 _voice.Voice = _voice.GetVoices(string.Empty, string.Empty).Item(0); //语音速度，范围-10到10，默认是0 _voice.Rate = 0; //语音音量，范围0到100，默认是100 _voice.Volume = 100; &#125; public void Play(string content) &#123; Stop(); //同步朗读(同步朗读时系统会停在这里，直到朗读完毕才会往下执行，建议使用异步朗读) // voice.Speak(content); //异步朗读 _voice.Speak(content, SpeechVoiceSpeakFlags.SVSFlagsAsync); &#125; /// &lt;summary&gt; /// 暂停 /// &lt;/summary&gt; public void Pause() &#123; _voice.Pause(); &#125; /// &lt;summary&gt; /// 恢复 /// &lt;/summary&gt; public void Recovery() &#123; _voice.Resume(); &#125; /// &lt;summary&gt; /// 停止 /// &lt;/summary&gt; public void Stop() &#123; _voice.Speak(string.Empty, SpeechVoiceSpeakFlags.SVSFPurgeBeforeSpeak); &#125; private void OnDestroy() &#123; // 异步朗读在unity停止后不会自动停止 Stop(); &#125; &#125;&#125; Unity打包后程序崩溃问题 unity打包后运行到需要播报语音的代码时会发生崩溃，并且没有崩溃提示 解决办法 测试环境 win10 unity 2020.3.34f1c2 发布程序为 .Net 4.X 打包后需要把对应unity安装路径下的2020.3.34f1c2\\Editor\\Data\\MonoBleedingEdge\\lib\\mono\\4.5\\CustomMarshalers.dll CustomMarshalers.dll拷贝到打包程序的根目录下 注意:必须是根目录下 经测试只能使用版本号后边不带API的 CustomMarshalers.dll 库（未完全测试）例如 4.5.1-api下的CustomMarshalers.dll 就会发生崩溃 xclikee&#x2F;SpeechLib: 文本转语音库 - Gogs (local.xclikee.top)参考微软SAPI（The Microsoft Speech API）：让你的软件能说会道 Zoomicon&#x2F;SpeechLib：使用 Windows.Speech 或 Microsoft.Speech 以及可选的 Kinect V1 Sensor 麦克风阵列进行语音合成和识别的库 (github.com)","tags":["音频"],"categories":["Unity"]},{"title":"已知屏幕的分辨率，整么计算屏幕比例？","path":"/2025/03/24/已知屏幕的分辨率怎么计算屏幕比例/","content":"屏幕比例都知道常见的手机屏幕比例有16:9、18:9、19.5:9…日常开发过程中，一般关心的是屏幕的分辨率，很少关心屏幕的比例。可是我就遇到了，在此记录一下计算方法。 已知屏幕的分辨率求屏幕比例19201080的屏幕一般接触得毕竟多，都知道该屏幕比例为16:9。计算式： 1920÷120:1080÷120 = 16:9其中120是最大*公约数，就是能够被 1920和 1080 共同整除的数。我们的主要逻辑就是计算出最大公约数。 计算代码如下： 1234567891011//整除数计算，欧几里德算法function aliquot (width, height) &#123;\tif (width % height == 0) return height;\treturn aliquot(height, width % height);&#125;var width = 1920; //宽度var height = 1080; //高度var divisor = aliquot(width, height); //获整除数var ratio = (width/divisor )+&#x27;:&#x27;+(height/divisor ); //比例console.log(&#x27;屏幕比例为&#x27;+ratio); //屏幕比例为16:9 原文链接","categories":["Unity"]},{"title":"C#随机打乱List数组中项的顺序","path":"/2025/03/24/随机打乱List数组中项的顺序/","content":"突然有一个需求，要求数组中数据在返回前进行随机打乱，于是就记录下来。 方法一1234567891011121314151617 public static void ListRandom&lt;T&gt;(List&lt;T&gt; sources) &#123; Random rd = new Random(); int index = 0; T temp; for (int i = 0; i &lt; sources.Count; i++) &#123; index = rd.Next(0, sources.Count - 1); if (index != i) &#123; temp = sources[i]; sources[i] = sources[index]; sources[index] = temp; &#125; &#125; &#125; 方法二12345678910public static List&lt;T&gt; ListRandom&lt;T&gt;(List&lt;T&gt; sources) &#123; var random = new Random(); var resultList = new List&lt;T&gt;(); foreach (var item in sources) &#123; resultList.Insert(random.Next(resultList.Count), item); &#125; return resultList; &#125;","categories":["C#"]},{"title":"Texture2d 缩略图","path":"/2025/03/24/Texture2d-缩略图/","content":"制作Texture2d 的缩略图更改Texture的尺寸，并返回新尺寸的 texture 用法：var newText = texture.NewSize(128, 128); 123456789101112131415161718192021222324252627282930313233 /// &lt;summary&gt;/// Texture 扩展/// &lt;/summary&gt;public static class TextureExtent&#123; /// &lt;summary&gt; /// 创建新尺寸的 Texture /// &lt;/summary&gt; /// &lt;param name=&quot;tex&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;width&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;height&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Texture NewSize(this Texture tex, int width, int height) &#123; if (null == tex) return null; tex.filterMode = FilterMode.Point; RenderTexture rt = RenderTexture.GetTemporary(width, height); rt.filterMode = FilterMode.Point; RenderTexture.active = rt; Graphics.Blit(tex, rt); var nTex = new Texture2D(width, height); nTex.ReadPixels(new Rect(0, 0, width, height), 0, 0); nTex.Apply(); RenderTexture.active = null; return nTex; &#125;&#125;","tags":["UI"],"categories":["Unity"]},{"title":"FFMPEG滤镜使用","path":"/2025/03/24/FFMPEG滤镜使用/","content":"说明滤镜（filter）详细介绍参考官方文档，主要使用了libavfilter库进行音视频处理。 常用的滤镜功能，像图像加水印&#x2F;字幕、去logo、图形旋转缩放等，但滤镜不仅仅包括视频部分，还包括音频处理的，像变声变调、声场控制（重低音&#x2F;留声机&#x2F;摇滚等效果）。 下面介绍滤镜类中常用命令 key1.去除水印该需求实现分为两步：step1.确认水印位置和效果；step2.位置和效果反复调整合适了，再转码 step1 1ffplay -i Tuesday00.mp4 -vf delogo=x=30:y=40:w=350:h=60:show=1,scale=640x480 其中，参数-vf指视频的滤镜处理（video filter），后面跟参数（水印区域：x&#x2F;y&#x2F;w&#x2F;h，是否圈住区域：show，缩放处理：scale），注意各子处理模块间（delogo``与scale）用”逗号”分隔，子处理模块内的各参数用“冒号”分割。 如果不想缩放处理，但是视频w&#x2F;h太大了，以至于超出了显示器显示区域的范围，可以控制播放窗口的大小。使用-x或-y指定播放窗口的宽或高。 step2 1ffmpeg -i Tuesday00.mp4 -vf delogo=x=30:y=40:w=350:h=60:show=0,scale=640x480 -c:v libx264 -c:a copy output.mp4 尝试了多次，确定好区域后，可以进行转码了。注意一点，show要关掉（show=0，否则delogo区域出现绿框），video转码参数（-c:v libx264）可以不带，系统默认使用x264编码。 key2.去除某个时间段的水印在上面Key2.step2命令中增加时间控制信息： -ss 5 -t 10（从第5秒开始，持续10s，共10秒钟长的视频） 1ffmpeg -i Tuesday00.mp4 -ss 5 -t 10 -vf delogo=x=30:y=40:w=350:h=60:show=0,scale=640x480 -c:v libx264 -c:a copy output.mp4 注意：-ss 5 -t 10参数，对于ffmpeg来说，放在input_file前和后貌似没什么差别，都是转成10秒钟长度的视频文件。 另外一点增强型需求：假如有多个时间段需要去除水印，例如，第0-15秒之间某个区域需要去除，还有20-30秒之间的另外一个区域水印去除。 这个需求的方法还没找到，有知道的同学们麻烦告知一下。目前我使用了比较笨的方法，就是多次转码。 key3.同时去除多个区域的水印在Key1中的step1命令中再增加一个delogo参数，即命令为： 1ffplay -i Tuesday00.mp4 -vf delogo=x=30:y=40:w=350:h=60:show=1,delogo=x=230:y=240:w=350:h=60:show=1 -y 300 确定好位置后，再用ffmpeg转码： 1ffmpeg -i Tuesday00.mp4 -vf delogo=x=30:y=40:w=350:h=60:show=1,delogo=x=230:y=240:w=350:h=60:show=1 output.mp4 key4.添加文字水印与Key1类型，先用ffplay确认位置和效果，再用ffmpeg进行滤镜+转码。 step1 1ffplay -i Tuesday00.mp4 -vf &quot;drawtext=fontfile=msyh.ttc:text=&#x27;Hello,world&#x27;:x=30:y=60:fontsize=120:fontcolor=yellow&quot; 注意，本地的字体文件（fontfile&#x3D;msyh.ttc）可以不指定，找不到了用系统使用默认的。 step2 1ffmpeg -i Tuesday00.mp4 -vf &quot;drawtext=fontfile=msyh.ttc:text=&#x27;Hello,world&#x27;:x=30:y=60:fontsize=120:fontcolor=yellow&quot; output.mp4 key5.给视频添加封面其实是将指定图片作为视频的前几帧（只指定为第一帧时，有的平台可能不使用首帧作为缩略图则达不到效果）。核心思想是，图片转为包含若干帧图像的视频流，再跟主视频合并。 step1 1ffmpeg.exe -r 25 -loop 1 -i img.jpg -vcodec libx264 -s 720x1280 -frames 25 -r 25 img_25f.mp4 其中，参数-r 25 -loop 1代表以25fps速度反复读取输入文件。参数-frames 25指只编码25帧，-r 25指定输出文件帧率为25fps。那么命令结果是，生成了1秒钟的视频文件（用工具分析文件，会发现：第一帧的关键帧size较大，后面的B&#x2F;P帧非常小，只有几十Bytes大小，因为h264编码p或b帧时，使用的帧间编码技术，参考了第一帧I帧内容编码而来）。 step2 1ffmpeg -f concat -i concat.txt -c copy output.mp4 其中，参数-f concat指视频合并；参数-i concat.txt指定输入文件列表，如下格式： 12file input1.mp4file input2.mp4 注意：如果合并时出现如下异常：[concat @ 0x2690e00] DTS 4079 &lt; 8156 out of order0:02:43.12 bitrate&#x3D; 676.2kbits&#x2F;s 可以这样做：把两个mp4视频分别抽取出裸流，保存为两个独立的h264文件，再合并，这样就不会出现合并时的dts异常问题了（因为裸码流根本没有pts&#x2F;dts）抽取出裸码流命令为：命令为： 1ffmpeg -i input.mp4 -c:v copy -an output.mp4 key6.将视频放在黑板上另外一种说法是，将视频放在幕布上。 1ffmpeg -i input.mp4 -vf pad=720:1280:100:200:black output.mp4 其中，参数pad=720:1280:100:200指定了幕布的宽&#x2F;高以及视频（左上角）放置在该幕布中的位置（如果放在幕布左上角，参数为pad=720:1280:0:0），参数black指定了幕布的颜色。 另外一点需注意，输入视频size不能超过了幕布size，否则出错（Padded dimensions cannot be smaller than input dimensions.），但允许视频（经过变换后）右下角坐标超过幕布右下角坐标。 key7.视频等比例缩放后置于幕布上目标与上面的类似，但有一些差异：Key6中的视频宽度和高度可能都小于幕布size，导致使用滤镜后得到的视频，四个周边都有黑框，而本条目标是将视频宽度缩放到幕布的宽度，再贴到幕布上，留下只有上面和下面是黑色的电影效果。 123fmpeg -i input.mp4 -vf &quot;scale=720:(ih*720/iw),pad=720:1280:0:(1280-(ih*720/iw))/2:black&quot; -y output.mp4 // 将视频等比例缩放到720的宽度，再贴到幕布（720x1280）中央。ffmpeg -i input.mp4 -vf &quot;scale=720:(ih*ow/iw),pad=720:1280:0:(oh-(ih*ow/iw))/2:black&quot; -y output.mp4 //上条命令的简写，其中iw、ih指输入（input.mp4文件）的宽高，ow、oh指（pad——幕布）输出的宽高。 注意一点，如果在视频在幕布上超出了幕布的宽或高，则视频在宽（x轴、水平方向）或高（y轴、垂直方向）方向上会自动居中对齐，因此参数(oh-(ih*ow/iw))/2用来手动指定垂直方向上居中对齐略有些复杂，可以也不用写这么复杂，例如直接写成”oh”或”-1”，就会自动上下居中了。 key8.滚动的字幕类似于点视台放的电视剧下面的流动广告或通知。 1ffmpeg -i input.mp4 -vf &quot;drawtext=text=&#x27;李公公给老佛爷讲段子&#x27;: y=10:x=(mod(5*n\\,w+tw)-tw):fontsize=60:fontcolor=yellow:shadowy=10&quot; -y output.mp4 其中，drawtext的参数y=10:x=(mod(5*n\\,w+tw)-tw)为字幕（的首字）的位置：始终固定在同一个高度上，但水平方向上是移动的，n指第几帧图像，5*n指移动速度（5pix&#x2F;f），符号“\\”用于指示后面的特殊符号“，”，w&#x2F;h指输入视频的宽高，tw指总字宽（fontsize控制，即字数x字体宽fontsize），mod指数学上的求余。因此，经计算后该position范围为[-tw, w]，效果为：一排字从视频左端开始显现，到视频右边消失，之后再从左边显现，呈现出循环显示的特点。 参数shadowy=10指阴影在垂直方向上的偏移距离。 注意一点，中文字体的fontsize跟视频size是匹配的，但是英文字体不是匹配的。简单说来，如果视频宽为600，字体fontsize&#x3D;60，那么中文字符串如果有10个字，则恰好铺满视频宽度，如果是英文字符串，则需要更多字才能铺满视频宽度。 key9.视频裁剪(crop)处理该需求类似于，一张纸片或布，只需要中间的一部分（矩形区域），其他区域都裁掉不要。 1fmpeg -i input.mp4 -vf crop=1280:720:0:0 output.mp4 其中，crop的参数格式为w:h:x:y，w、h为输出视频的宽和高，x、y标记输入视频中的某点，将该点作为基准点，向右下进行裁剪得到输出视频。如果x y不写的话，默认居中剪切。 key10.添加居中字幕，字体缩小后再放大先用ffplay验证效果，再使用ffmpeg转码（转码命令略，后续只给出ffplay的命令）。 1ffplay -i input.mp4 -vf drawtext=text=&#x27;hello\\,world&#x27;:x=\\(w-text_w\\)/2:y=\\(h-text_h\\)/2:fontsize=abs\\(\\(300\\-2\\*n\\)\\):fontcolor=yellow:fix_bounds=1 key11. 四窗口画面，只使用两个窗口显示视频1ffplay -i Tuesday02.mp4 -vf &quot;split [main][tmp]; [main] scale=iw/2:ih/2 [a]; [tmp] scale=iw/2:ih/2, pad=iw*2:ih*2:iw:0:black [b]; [b][a] overlay=0:H/2&quot; 注意：参数overlay=0:H/2，由于两个输入视频，不能使用iw或ih，因为不知道使用哪个的，而用大写的W/H表示第一个（主）的宽&#x2F;高，小写的w/h表示第二个（次）的宽&#x2F;高。 显示效果如下： key12.16：9的视频方便手机竖屏播放，上下部分虚化1ffplay.exe -i dajiangdongqu_symphony.mp4 -vf &quot;split[fg0][bg0];[bg0]scale=720:1280,boxblur=10:10[bg1];[fg0]scale=720:(720*ih/iw)[fg1];[bg1][fg1]overlay=0:(H-h)/2,setdar=9/16&quot; 手机竖屏播放时，普通720p(1280x720)只会在屏幕中间显示，上下部分黑屏。如果想让上下的黑屏用虚化的效果调换掉，即变化后的视频分辨率近似为手机LCD分辨率，又能恰好铺满桌面而又不产生非等比例拉伸效果，即抖音上常见的竖屏视频效果。 需要说明几点： bg1为最终的背景，即虚化后的图像，其先进行缩放到720*1280的scale操作，再进行虚化blur。 fg1为最终的前景，其由原始视频等比例缩放而来，例如：1920x1080的图形，缩放得到720x的图形，如果不希望图像被被拉伸（即等比例缩放），那么可得出x&#x3D;7201080&#x2F;1920，即720*ih&#x2F;iw操作。 目前手机LCD的分辨率，一般为9：16(例如720x1280，方便电影大片横屏播放)，后来手机的刘海慢慢消失，宽高比例慢慢变成了9：18乃至9：20，但主流的高&#x2F;宽比例仍是2左右，因此生成的视频的分辨率，最好接近这个比例。从抖音上下载的片子，目前看到的都是720x1280的尺寸。 setdar&#x3D;9&#x2F;16的目的，需要经过播放验证才能明白其中道理。虽然生成的片子是720x1280，但播放器播放时还可能参考显示比例（DisplayAspectRatio）这个参数（从技术角度上讲，该值在sps-vui中定义），一些播放器会根据这个参数来强制对图形进行拉伸处理。例如，解码后得到的图像为720x1280，如果DAR&#x3D;16：9，则会再把本来竖着的图像压扁后再进行播放，这样的播放体验就不太好了。 key13.为视频添加图片水印1ffplay.exe -i djdq.mp4 -vf &quot;movie=haha.jpg[wm];[in][wm] overlay=0:0&quot; 几点说明： 123456movie=haha.jpg[wm] //指定图片水印路径，wm——WaterMark[in][wm] //输入的片源（即djdq.mp4），以及水印（由前面指定的，即movie=haha.jpg）overlay=0:0 //图片水印（左上角）放在视频中的位置，0:0指左上角，W/2:H/2指视频中间位置上开始叠加图片 另外一种方式，在右下角加水印： 1ffplay -i input.mp4 -i logo.png -filter_complex &#x27;overlay=main_w-overlay_w-10:main_h-overlay_h-10&#x27; 原文 FFMPEG滤镜使用","categories":["ffmpeg"]},{"title":"FFmpeg 视频处理入门教程","path":"/2025/03/24/FFmpeg-视频处理入门教程/","content":"[FFmpeg](FFmpeg 是视频处理最常用的开源软件。) 是视频处理最常用的开源软件。 它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码&#x2F;解码实现 FFmpeg 本身是一个庞大的项目，包含许多组件和库文件，最常用的是它的命令行工具。本文介绍 FFmpeg 命令行如何处理视频，比桌面视频处理软件更简洁高效。 如果你还没安装，可以根据官方文档 先完成安装。 概念介绍 FFmpeg 用法之前，需要了解一些视频处理的基本概念。 容器视频文件本身其实是一个容器（container），里面包括了视频和音频，也可能有字幕等其他内容。 常见的容器格式有以下几种。一般来说，视频文件的后缀名反映了它的容器格式。 1234MP4MKVWebMAVI 下面的命令查看 FFmpeg 支持的容器。 1ffmpeg -formats 编码格式视频和音频都需要经过编码，才能保存成文件。不同的编码格式（CODEC），有不同的压缩率，会导致文件大小和清晰度的差异。 常用的视频编码格式如下。 123H.262H.264H.265 上面的编码格式都是有版权的，但是可以免费使用。此外，还有几种无版权的视频编码格式。 123VP8VP9AV1 常用的音频编码格式如下。 12MP3AAC 上面所有这些都是有损的编码格式，编码后会损失一些细节，以换取压缩后较小的文件体积。无损的编码格式压缩出来的文件体积较大，这里就不介绍了。 下面的命令可以查看 FFmpeg 支持的编码格式，视频编码和音频编码都在内。 1ffmpeg -codecs 编码器编码器（encoders）是实现某种编码格式的库文件。只有安装了某种格式的编码器，才能实现该格式视频&#x2F;音频的编码和解码。 以下是一些 FFmpeg 内置的视频编码器。 12345libx264：最流行的开源 H.264 编码器NVENC：基于 NVIDIA GPU 的 H.264 编码器libx265：开源的 HEVC 编码器libvpx：谷歌的 VP8 和 VP9 编码器libaom：AV1 编码器 音频编码器如下。 12libfdk-aacaac 下面的命令可以查看 FFmpeg 已安装的编码器。 1ffmpeg -encoders FFmpeg 的使用格式FFmpeg 的命令行参数非常多，可以分成五个部分。 1ffmpeg &#123;1&#125; &#123;2&#125; -i &#123;3&#125; &#123;4&#125; &#123;5&#125; 上面命令中，五个部分的参数依次如下。 123451. 全局参数2. 输入文件参数3. 输入文件4. 输出文件参数5. 输出文件 参数太多的时候，为了便于查看，ffmpeg 命令可以写成多行。 123456ffmpeg \\[全局参数] \\[输入文件参数] \\-i [输入文件] \\[输出文件参数] \\[输出文件] 下面是一个例子。 123456ffmpeg \\-y \\ # 全局参数-c:a libfdk_aac -c:v libx264 \\ # 输入文件参数-i input.mp4 \\ # 输入文件-c:v libvpx-vp9 -c:a libvorbis \\ # 输出文件参数output.webm # 输出文件 上面的命令将 mp4 文件转成 webm 文件，这两个都是容器格式。输入的 mp4 文件的音频编码格式是 aac，视频编码格式是 H.264；输出的 webm 文件的视频编码格式是 VP9，音频格式是 Vorbis。 如果不指明编码格式，FFmpeg 会自己判断输入文件的编码。因此，上面的命令可以简单写成下面的样子。 1ffmpeg -i input.avi output.mp4 常用命令行参数FFmpeg 常用的命令行参数如下。 123456789-c：指定编码器-c copy：直接复制，不经过重新编码（这样比较快）-c:v：指定视频编码器-c:a：指定音频编码器-i：指定输入文件-an：去除音频流-vn： 去除视频流-preset：指定输出的视频质量，会影响文件的生成速度，有以下几个可用的值 ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow。-y：不经过确认，输出时直接覆盖同名文件。 常见用法下面介绍 FFmpeg 几种常见用法。 查看文件信息查看视频文件的元信息，比如编码格式和比特率，可以只使用-i参数。 1ffmpeg -i input.mp4 上面命令会输出很多冗余信息，加上-hide_banner参数，可以只显示元信息。 1ffmpeg -i input.mp4 -hide_banner 转换编码格式转换编码格式（transcoding）指的是， 将视频文件从一种编码转成另一种编码。比如转成 H.264 编码，一般使用编码器libx264，所以只需指定输出文件的视频编码器即可。 1ffmpeg -i [input.file] -c:v libx264 output.mp4 下面是转成 H.265 编码的写法。 1ffmpeg -i [input.file] -c:v libx265 output.mp4 转换容器格式转换容器格式（transmuxing）指的是，将视频文件从一种容器转到另一种容器。下面是 mp4 转 webm 的写法。 1ffmpeg -i input.mp4 -c copy output.webm 上面例子中，只是转一下容器，内部的编码格式不变，所以使用-c copy指定直接拷贝，不经过转码，这样比较快。 调整码率调整码率（transrating）指的是，改变编码的比特率，一般用来将视频文件的体积变小。下面的例子指定码率最小为964K，最大为3856K，缓冲区大小为 2000K。 1234ffmpeg \\-i input.mp4 \\-minrate 964K -maxrate 3856K -bufsize 2000K \\output.mp4 改变分辨率（transsizing）下面是改变视频分辨率（transsizing）的例子，从 1080p 转为 480p 。 1234ffmpeg \\-i input.mp4 \\-vf scale=480:-1 \\output.mp4 提取音频有时，需要从视频里面提取音频（demuxing），可以像下面这样写。 1234 ffmpeg \\-i input.mp4 \\-vn -c:a copy \\output.aac 上面例子中，-vn表示去掉视频，-c:a copy表示不改变音频编码，直接拷贝。 添加音轨添加音轨（muxing）指的是，将外部音频加入视频，比如添加背景音乐或旁白。 123ffmpeg \\-i input.aac -i input.mp4 \\output.mp4 上面例子中，有音频和视频两个输入文件，FFmpeg 会将它们合成为一个文件。 截图下面的例子是从指定时间开始，连续对1秒钟的视频进行截图。 12345ffmpeg \\-y \\-i input.mp4 \\-ss 00:01:24 -t 00:00:01 \\output_%3d.jpg 如果只需要截一张图，可以指定只截取一帧。 12345ffmpeg \\-ss 01:23:45 \\-i input \\-vframes 1 -q:v 2 \\output.jpg 上面例子中，-vframes 1指定只截取一帧，-q:v 2表示输出的图片质量，一般是1到5之间（1 为质量最高）。 裁剪裁剪（cutting）指的是，截取原始视频里面的一个片段，输出为一个新视频。可以指定开始时间（start）和持续时间（duration），也可以指定结束时间（end）。 12ffmpeg -ss [start] -i [input] -t [duration] -c copy [output]ffmpeg -ss [start] -i [input] -to [end] -c copy [output] 下面是实际的例子。 12ffmpeg -ss 00:01:50 -i [input] -t 10.5 -c copy [output]ffmpeg -ss 2.5 -i [input] -to 10 -c copy [output] 上面例子中，-c copy表示不改变音频和视频的编码格式，直接拷贝，这样会快很多。 为音频添加封面有些视频网站只允许上传视频文件。如果要上传音频文件，必须为音频添加封面，将其转为视频，然后上传。 下面命令可以将音频文件，转为带封面的视频文件。 12345ffmpeg \\-loop 1 \\-i cover.jpg -i input.mp3 \\-c:v libx264 -c:a aac -b:a 192k -shortest \\output.mp4 上面命令中，有两个输入文件，一个是封面图片cover.jpg，另一个是音频文件input.mp3。-loop 1参数表示图片无限循环，-shortest参数表示音频文件结束，输出视频就结束。 参考链接FFmpeg libav tutorial Digital video introduction FFmpeg encoding and editing course Making Slideshows w&#x2F;FFMpeg The Complete Guide for Using ffmpeg in Linux Adding subtitles to your videos the easy way 原文 FFmpeg 视频处理入门教程","categories":["ffmpeg"]},{"title":"c#按字符串中的数字排序问题","path":"/2025/03/24/按字符串中的数字排序问题/","content":"前因在.net 的framewrok框架中提供的排序方法中，如string.sort() 或ArrayList.Sort()方法。这两个方法对字符串排序时，如果字符串中含有数字，则不会按数字大小排序。如： 123456ArrayList list = new ArrayList(4);List.Add(“aa1”);List.Add(“aa100);List.Add(“aa10);List.Add(“aa2”);List.Sort(); 我们希望排序后的顺序为： aa1,aa2,aa10,aa100 实际上排序顺序为：aa1,aa10,aa100,aa2 重写函数 为了序排序后的效果为我们想要的按字符串中的数值排序，我们必须重写字符串的比较函数。 由于比较两个字符串时，是逐个比较字符，先从第一个字符开始比较，取出两个字符串中的第一个字符比较，如果比较结果是大于，则说明第一个字符串大于第二个字符串，如果小于，则说明第一个字符串小于第二字符串，如果等于，则比较两个字符串中的第二个字符。如果比到最后也是相等，则说明两个字符串一样大，如果有一个字符串要多一些字符，则这个字符串在大一些。 我们改进这个算法：在比较过程中如果发现数字，则先不进行比较，看下一个字符是否为数字，这个取出两个字符串中的数字，按数字的数值大小来进行比较。如果相等再取一个字符进行比较。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869///&lt;summary&gt; ///主要用于文件名的比较。 ///&lt;/summary&gt; public class FilesNameComparerClass : IComparer &#123; ///&lt;summary&gt; ///比较两个字符串，如果含用数字，则数字按数字的大小来比较。 ///&lt;/summary&gt; ///&lt;param name=&quot;x&quot;&gt;&lt;/param&gt; ///&lt;param name=&quot;y&quot;&gt;&lt;/param&gt; ///&lt;returns&gt;&lt;/returns&gt; public int Compare(object x, object y) &#123; if (x == null || y == null) throw new ArgumentException(&quot;Parameters can&#x27;t be null&quot;); string fileA = x as string; string fileB = y as string; char[] arr1 = fileA.ToCharArray(); char[] arr2 = fileB.ToCharArray(); int i = 0, j = 0; while (i &lt; arr1.Length &amp;&amp; j &lt; arr2.Length) &#123; if (char.IsDigit(arr1[i]) &amp;&amp; char.IsDigit(arr2[j])) &#123; string s1 = &quot;&quot;, s2 = &quot;&quot;; while (i &lt; arr1.Length &amp;&amp; char.IsDigit(arr1[i])) &#123; s1 += arr1[i]; i++; &#125; while (j &lt; arr2.Length &amp;&amp; char.IsDigit(arr2[j])) &#123; s2 += arr2[j]; j++; &#125; if (int.Parse(s1) &gt; int.Parse(s2)) &#123; return 1; &#125; if (int.Parse(s1) &lt; int.Parse(s2)) &#123; return -1; &#125; &#125; else &#123; if (arr1[i] &gt; arr2[j]) &#123; return 1; &#125; if (arr1[i] &lt; arr2[j]) &#123; return -1; &#125; i++; j++; &#125; &#125; if (arr1.Length == arr2.Length) return 0; return arr1.Length &gt; arr2.Length ? 1 : -1; &#125; &#125; 用法123IComparer fileNameComparer = new FilesNameComparerClass();List.Sort( fileNameComparer ); 这样排序后的字符串就为按字符串中的数值排序了,为： aa1,aa2,aa10,aa100","categories":["C#"]},{"title":"unity 常用字符","path":"/2025/03/24/unity-常用字符/","content":"一乙二十丁厂七卜人入八九几儿了力乃刀又三于干亏士工土才寸下大丈与万上小口巾山千乞川亿个勺久凡及夕丸么广亡门义之尸弓己已子卫也女飞刃习叉马乡丰王井开夫天无元专云扎艺木五支厅不太犬区历尤友匹车巨牙屯比互切瓦止少日中冈贝内水见午牛手毛气升长仁什片仆化仇币仍仅斤爪反介父从今凶分乏公仓月氏勿欠风丹匀乌凤勾文六方火为斗忆订计户认心尺引丑巴孔队办以允予劝双书幻玉刊示末未击打巧正扑扒功扔去甘世古节本术可丙左厉右石布龙平灭轧东卡北占业旧帅归且旦目叶甲申叮电号田由史只央兄叼叫另叨叹四生失禾丘付仗代仙们仪白仔他斥瓜乎丛令用甩印乐句匆册犯外处冬鸟务包饥主市立闪兰半汁汇头汉宁穴它讨写让礼训必议讯记永司尼民出辽奶奴加召皮边发孕圣对台矛纠母幼丝式刑动扛寺吉扣考托老执巩圾扩扫地扬场耳共芒亚芝朽朴机权过臣再协西压厌在有百存而页匠夸夺灰达列死成夹轨邪划迈毕至此贞师尘尖劣光当早吐吓虫曲团同吊吃因吸吗屿帆岁回岂刚则肉网年朱先丢舌竹迁乔伟传乒乓休伍伏优伐延件任伤价份华仰仿伙伪自血向似后行舟全会杀合兆企众爷伞创肌朵杂危旬旨负各名多争色壮冲冰庄庆亦刘齐交次衣产决充妄闭问闯羊并关米灯州汗污江池汤忙兴宇守宅字安讲军许论农讽设访寻那迅尽导异孙阵阳收阶阴防奸如妇好她妈戏羽观欢买红纤级约纪驰巡寿弄麦形进戒吞远违运扶抚坛技坏扰拒找批扯址走抄坝贡攻赤折抓扮抢孝均抛投坟抗坑坊抖护壳志扭块声把报却劫芽花芹芬苍芳严芦劳克苏杆杠杜材村杏极李杨求更束豆两丽医辰励否还歼来连步坚旱盯呈时吴助县里呆园旷围呀吨足邮男困吵串员听吩吹呜吧吼别岗帐财针钉告我乱利秃秀私每兵估体何但伸作伯伶佣低你住位伴身皂佛近彻役返余希坐谷妥含邻岔肝肚肠龟免狂犹角删条卵岛迎饭饮系言冻状亩况床库疗应冷这序辛弃冶忘闲间闷判灶灿弟汪沙汽沃泛沟没沈沉怀忧快完宋宏牢究穷灾良证启评补初社识诉诊词译君灵即层尿尾迟局改张忌际陆阿陈阻附妙妖妨努忍劲鸡驱纯纱纳纲驳纵纷纸纹纺驴纽奉玩环武青责现表规抹拢拔拣担坦押抽拐拖拍者顶拆拥抵拘势抱垃拉拦拌幸招坡披拨择抬其取苦若茂苹苗英范直茄茎茅林枝杯柜析板松枪构杰述枕丧或画卧事刺枣雨卖矿码厕奔奇奋态欧垄妻轰顷转斩轮软到非叔肯齿些虎虏肾贤尚旺具果味昆国昌畅明易昂典固忠咐呼鸣咏呢岸岩帖罗帜岭凯败贩购图钓制知垂牧物乖刮秆和季委佳侍供使例版侄侦侧凭侨佩货依的迫质欣征往爬彼径所舍金命斧爸采受乳贪念贫肤肺肢肿胀朋股肥服胁周昏鱼兔狐忽狗备饰饱饲变京享店夜庙府底剂郊废净盲放刻育闸闹郑券卷单炒炊炕炎炉沫浅法泄河沾泪油泊沿泡注泻泳泥沸波泼泽治怖性怕怜怪学宝宗定宜审宙官空帘实试郎诗肩房诚衬衫视话诞询该详建肃录隶居届刷屈弦承孟孤陕降限妹姑姐姓始驾参艰线练组细驶织终驻驼绍经贯奏春帮珍玻毒型挂封持项垮挎城挠政赴赵挡挺括拴拾挑指垫挣挤拼挖按挥挪某甚革荐巷带草茧茶荒茫荡荣故胡南药标枯柄栋相查柏柳柱柿栏树要咸威歪研砖厘厚砌砍面耐耍牵残殃轻鸦皆背战点临览竖省削尝是盼眨哄显哑冒映星昨畏趴胃贵界虹虾蚁思蚂虽品咽骂哗咱响哈咬咳哪炭峡罚贱贴骨钞钟钢钥钩卸缸拜看矩怎牲选适秒香种秋科重复竿段便俩贷顺修保促侮俭俗俘信皇泉鬼侵追俊盾待律很须叙剑逃食盆胆胜胞胖脉勉狭狮独狡狱狠贸怨急饶蚀饺饼弯将奖哀亭亮度迹庭疮疯疫疤姿亲音帝施闻阀阁差养美姜叛送类迷前首逆总炼炸炮烂剃洁洪洒浇浊洞测洗活派洽染济洋洲浑浓津恒恢恰恼恨举觉宣室宫宪突穿窃客冠语扁袄祖神祝误诱说诵垦退既屋昼费陡眉孩除险院娃姥姨姻娇怒架贺盈勇怠柔垒绑绒结绕骄绘给络骆绝绞统耕耗艳泰珠班素蚕顽盏匪捞栽捕振载赶起盐捎捏埋捉捆捐损都哲逝捡换挽热恐壶挨耻耽恭莲莫荷获晋恶真框桂档桐株桥桃格校核样根索哥速逗栗配翅辱唇夏础破原套逐烈殊顾轿较顿毙致柴桌虑监紧党晒眠晓鸭晃晌晕蚊哨哭恩唤啊唉罢峰圆贼贿钱钳钻铁铃铅缺氧特牺造乘敌秤租积秧秩称秘透笔笑笋债借值倚倾倒倘俱倡候俯倍倦健臭射躬息徒徐舰舱般航途拿爹爱颂翁脆脂胸胳脏胶脑狸狼逢留皱饿恋桨浆衰高席准座脊症病疾疼疲效离唐资凉站剖竞部旁旅畜阅羞瓶拳粉料益兼烤烘烦烧烛烟递涛浙涝酒涉消浩海涂浴浮流润浪浸涨烫涌悟悄悔悦害宽家宵宴宾窄容宰案请朗诸读扇袜袖袍被祥课谁调冤谅谈谊剥恳展剧屑弱陵陶陷陪娱娘通能难预桑绢绣验继球理捧堵描域掩捷排掉堆推掀授教掏掠培接控探据掘职基著勒黄萌萝菌菜萄菊萍菠营械梦梢梅检梳梯桶救副票戚爽聋袭盛雪辅辆虚雀堂常匙晨睁眯眼悬野啦晚啄距跃略蛇累唱患唯崖崭崇圈铜铲银甜梨犁移笨笼笛符第敏做袋悠偿偶偷您售停偏假得衔盘船斜盒鸽悉欲彩领脚脖脸脱象够猜猪猎猫猛馅馆凑减毫麻痒痕廊康庸鹿盗章竟商族旋望率着盖粘粗粒断剪兽清添淋淹渠渐混渔淘液淡深婆梁渗情惜惭悼惧惕惊惨惯寇寄宿窑密谋谎祸谜逮敢屠弹随蛋隆隐婚婶颈绩绪续骑绳维绵绸绿琴斑替款堪搭塔越趁趋超提堤博揭喜插揪搜煮援裁搁搂搅握揉斯期欺联散惹葬葛董葡敬葱落朝辜葵棒棋植森椅椒棵棍棉棚棕惠惑逼厨厦硬确雁殖裂雄暂雅辈悲紫辉敞赏掌晴暑最量喷晶喇遇喊景践跌跑遗蛙蛛蜓喝喂喘喉幅帽赌赔黑铸铺链销锁锄锅锈锋锐短智毯鹅剩稍程稀税筐等筑策筛筒答筋筝傲傅牌堡集焦傍储奥街惩御循艇舒番释禽腊脾腔鲁猾猴然馋装蛮就痛童阔善羡普粪尊道曾焰港湖渣湿温渴滑湾渡游滋溉愤慌惰愧愉慨割寒富窜窝窗遍裕裤裙谢谣谦属屡强粥疏隔隙絮嫂登缎缓编骗缘瑞魂肆摄摸填搏塌鼓摆携搬摇搞塘摊蒜勤鹊蓝墓幕蓬蓄蒙蒸献禁楚想槐榆楼概赖酬感碍碑碎碰碗碌雷零雾雹输督龄鉴睛睡睬鄙愚暖盟歇暗照跨跳跪路跟遣蛾蜂嗓置罪罩错锡锣锤锦键锯矮辞稠愁筹签简毁舅鼠催傻像躲微愈遥腰腥腹腾腿触解酱痰廉新韵意粮数煎塑慈煤煌满漠源滤滥滔溪溜滚滨粱滩慎誉塞谨福群殿辟障嫌嫁叠缝缠静碧璃墙撇嘉摧截誓境摘摔聚蔽慕暮蔑模榴榜榨歌遭酷酿酸磁愿需弊裳颗嗽蜻蜡蝇蜘赚锹锻舞稳算箩管僚鼻魄貌膜膊膀鲜疑馒裹敲豪膏遮腐瘦辣竭端旗精歉熄熔漆漂漫滴演漏慢寨赛察蜜谱嫩翠熊凳骡缩慧撕撒趣趟撑播撞撤增聪鞋蕉蔬横槽樱橡飘醋醉震霉瞒题暴瞎影踢踏踩踪蝶蝴嘱墨镇靠稻黎稿稼箱箭篇僵躺僻德艘膝膛熟摩颜毅糊遵潜潮懂额慰劈操燕薯薪薄颠橘整融醒餐嘴蹄器赠默镜赞篮邀衡膨雕磨凝辨辩糖糕燃澡激懒壁避缴戴擦鞠藏霜霞瞧蹈螺穗繁辫赢糟糠燥臂翼骤鞭覆蹦镰翻鹰警攀蹲颤瓣爆疆壤耀躁嚼嚷籍魔灌蠢霸露囊罐匕刁丐歹戈夭仑讥冗邓艾夯凸卢叭叽皿凹囚矢乍尔冯玄邦迂邢芋芍吏夷吁吕吆屹廷迄臼仲伦伊肋旭匈凫妆亥汛讳讶讹讼诀弛阱驮驯纫玖玛韧抠扼汞扳抡坎坞抑拟抒芙芜苇芥芯芭杖杉巫杈甫匣轩卤肖吱吠呕呐吟呛吻吭邑囤吮岖牡佑佃伺囱肛肘甸狈鸠彤灸刨庇吝庐闰兑灼沐沛汰沥沦汹沧沪忱诅诈罕屁坠妓姊妒纬玫卦坷坯拓坪坤拄拧拂拙拇拗茉昔苛苫苟苞茁苔枉枢枚枫杭郁矾奈奄殴歧卓昙哎咕呵咙呻咒咆咖帕账贬贮氛秉岳侠侥侣侈卑刽刹肴觅忿瓮肮肪狞庞疟疙疚卒氓炬沽沮泣泞泌沼怔怯宠宛衩祈诡帚屉弧弥陋陌函姆虱叁绅驹绊绎契贰玷玲珊拭拷拱挟垢垛拯荆茸茬荚茵茴荞荠荤荧荔栈柑栅柠枷勃柬砂泵砚鸥轴韭虐昧盹咧昵昭盅勋哆咪哟幽钙钝钠钦钧钮毡氢秕俏俄俐侯徊衍胚胧胎狰饵峦奕咨飒闺闽籽娄烁炫洼柒涎洛恃恍恬恤宦诫诬祠诲屏屎逊陨姚娜蚤骇耘耙秦匿埂捂捍袁捌挫挚捣捅埃耿聂荸莽莱莉莹莺梆栖桦栓桅桩贾酌砸砰砾殉逞哮唠哺剔蚌蚜畔蚣蚪蚓哩圃鸯唁哼唆峭唧峻赂赃钾铆氨秫笆俺赁倔殷耸舀豺豹颁胯胰脐脓逛卿鸵鸳馁凌凄衷郭斋疹紊瓷羔烙浦涡涣涤涧涕涩悍悯窍诺诽袒谆祟恕娩骏琐麸琉琅措捺捶赦埠捻掐掂掖掷掸掺勘聊娶菱菲萎菩萤乾萧萨菇彬梗梧梭曹酝酗厢硅硕奢盔匾颅彪眶晤曼晦冕啡畦趾啃蛆蚯蛉蛀唬唾啤啥啸崎逻崔崩婴赊铐铛铝铡铣铭矫秸秽笙笤偎傀躯兜衅徘徙舶舷舵敛翎脯逸凰猖祭烹庶庵痊阎阐眷焊焕鸿涯淑淌淮淆渊淫淳淤淀涮涵惦悴惋寂窒谍谐裆袱祷谒谓谚尉堕隅婉颇绰绷综绽缀巢琳琢琼揍堰揩揽揖彭揣搀搓壹搔葫募蒋蒂韩棱椰焚椎棺榔椭粟棘酣酥硝硫颊雳翘凿棠晰鼎喳遏晾畴跋跛蛔蜒蛤鹃喻啼喧嵌赋赎赐锉锌甥掰氮氯黍筏牍粤逾腌腋腕猩猬惫敦痘痢痪竣翔奠遂焙滞湘渤渺溃溅湃愕惶寓窖窘雇谤犀隘媒媚婿缅缆缔缕骚瑟鹉瑰搪聘斟靴靶蓖蒿蒲蓉楔椿楷榄楞楣酪碘硼碉辐辑频睹睦瞄嗜嗦暇畸跷跺蜈蜗蜕蛹嗅嗡嗤署蜀幌锚锥锨锭锰稚颓筷魁衙腻腮腺鹏肄猿颖煞雏馍馏禀痹廓痴靖誊漓溢溯溶滓溺寞窥窟寝褂裸谬媳嫉缚缤剿赘熬赫蔫摹蔓蔗蔼熙蔚兢榛榕酵碟碴碱碳辕辖雌墅嘁踊蝉嘀幔镀舔熏箍箕箫舆僧孵瘩瘟彰粹漱漩漾慷寡寥谭褐褪隧嫡缨撵撩撮撬擒墩撰鞍蕊蕴樊樟橄敷豌醇磕磅碾憋嘶嘲嘹蝠蝎蝌蝗蝙嘿幢镊镐稽篓膘鲤鲫褒瘪瘤瘫凛澎潭潦澳潘澈澜澄憔懊憎翩褥谴鹤憨履嬉豫缭撼擂擅蕾薛薇擎翰噩橱橙瓢蟥霍霎辙冀踱蹂蟆螃螟噪鹦黔穆篡篷篙篱儒膳鲸瘾瘸糙燎濒憾懈窿缰壕藐檬檐檩檀礁磷了瞬瞳瞪曙蹋蟋蟀嚎赡镣魏簇儡徽爵朦臊鳄糜癌懦豁臀藕藤瞻嚣鳍癞瀑襟璧戳攒孽蘑藻鳖蹭蹬簸簿蟹靡癣羹鬓攘蠕巍鳞糯譬霹躏髓蘸镶瓤矗qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM+&#x3D;_-!@#$%^&amp;()1234567890&lt;&gt;,.?&#x2F;:”;’[]{}|《》？：“{}！@#￥%……&amp;（）——+，。、；‘【】·`","categories":["Unity"]},{"title":"判断一个点是否在三角形内","path":"/2025/03/24/判断一个点是否在三角形内/","content":"数学基础向量点乘（Dot Product）点乘比较简单，是相应元素的乘积的和： V1( x1, y1)+ V2(x2, y2) = x1*x2 + y1*y2 注意结果不是一个向量，而是一个标量（Scalar）。点乘有什么用呢，我们有： = |A||B|Cos(θ) θ是向量A和向量B见的夹角。这里|A|我们称为向量A的模(norm)，也就是A的长度， 在二维空间中就是|A| &#x3D; sqrt()。这样我们就和容易计算两条线的夹角： Cos(θ) = / (|A||B|) 这可以告诉我们如果点乘的结果，简称点积，为0的话就表示这两个向量垂直。当两向量平行时，点积有最大值.另外，点乘运算不仅限于2维空间，他可以推广到任意维空间. 叉乘（cross product）相对于点乘，叉乘可能更有用吧。2维空间中的叉乘是： V1(x1, y1) X V2(x2, y2) = x1y2 -y1x2 看起来像个标量，事实上叉乘的结果是个向量，方向在z轴上。上述结果是它的模。在二维空间里，让我们暂时忽略它的方向，将结果看成一个向量，那么这个结果类似于上述的点积，我们有： A x B = |A||B|Sin(θ) 然而角度 θ和上面点乘的角度有一点点不同，他是有正负的，是指从A到B的角度。另外还有一个有用的特征那就是叉积的绝对值就是A和B为两边说形成的平行四边形的面积。也就是AB所包围三角形面积的两倍。这个还是很显然的啦。在计算面积时，我们要经常用到叉积。 一次牛客的比赛中遇到了这个题，当时是用下面的方法一来实现的，之后看了些博客，发现还有好几种更好的方法，当时实现起来代码还显得特别不好看2333，太菜了。 判断点在三角形内面积法利用面积，如图中,求三角形面积的方法就可以用上面提到的利用叉积就行了，注意记得加上绝对值，因为叉积可能为负。还有种简单的方法是利用内角和为但效率低下，就不管了。 同侧法首先看一下这个问题，如何判断某两个点在某条直线的同一侧 根据向量的叉乘以及右手螺旋定则，AB^AM （^表示叉乘，这里向量省略了字母上面的箭头符号）的方向为向外指出屏幕，AB^AN也是向外指出屏幕，但AB^AO的方向是向内指向屏幕，因此M,N在直线AB的同侧，M ,O在直线AB的两侧。实际计算时，只需要考虑叉积的数值正负假设以上各点坐标为A(0,0), B(4,0), M(1,2), N(3,4), O(3,-4)， 则： AB^AM = (4,0)^(1,2) = 4*2 - 0*1 = 8 AB^AN = (4，0)^(3，4) = 4*4 – 0*3 = 16 AB^AO = (4,0)^(3,-4) = 4*-4 – 0*3 = –16 由上面的数值可知，可以根据数值的正负判断叉乘后向量的方向。即，如果叉积AB^AM 和 AB^AN的结果同号，那么M,N两点就在直线的同侧，否则不在同一侧。特殊地，如果点M在直线AB上，则AB^AM的值为0。（如果是在三维坐标系中，求出的叉积是一个向量，可以根据两个向量的点积结果正负来判断两个向量的是否指向同一侧）。 以上的问题解决了，就很容易的用来判断某个点是否在三角形内，如果P在三角形ABC内部，则满足以下三个条件：P,A在BC的同侧、P,B在AC的同侧、PC在AB的同侧。某一个不满足则表示P不在三角形内部。 一个不知道怎么命名的方法该方法也用到了向量。对于三角形ABC和一点P，可以有如下的向量表示： p点在三角形内部的充分必要条件是：1 &gt;&#x3D; u &gt;&#x3D; 0, 1 &gt;&#x3D; v &gt;&#x3D; 0, u+v &lt;&#x3D; 1。 已知A,B,C,P四个点的坐标，可以求出u，v，把上面的式子分别点乘向量AC和向量AB 解方程得到： 解出u，v后只需要看他们是否满足“1 &gt;&#x3D; u &gt;&#x3D; 0, 1 &gt;&#x3D; v &gt;&#x3D; 0, u+v &lt;&#x3D; 1”，如满足，则，p 在三角形内。 （u &#x3D; 0时，p在AB上， v &#x3D; 0时，p在AC上，两者均为0时，p和A重合） 又一个不知道怎么命名的算法该算法和算法2类似，可以看作是对算法2的简化，也是用到向量的叉乘。假设三角形的三个点按照顺时针（或者逆时针）顺序是A,B,C。对于某一点P，求出三个向量PA,PB,PC, 然后计算以下三个叉乘（^表示叉乘符号）： t1 &#x3D; PA^PB, t2 &#x3D; PB^PC, t3 &#x3D; PC^PA, 如果t1，t2，t3同号（同正或同负），那么P在三角形内部，否则在外部。 经过测试，算法4最快，算法3次之，接着算法2，算法1最慢。直观的从计算量上来看，也是算法4的计算量最少。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;list&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long ll;//类定义：二维向量class Vector2d&#123;public: double x_; double y_; public: Vector2d(double x, double y):x_(x), y_(y)&#123;&#125; Vector2d():x_(0), y_(0)&#123;&#125; //二维向量叉乘, 叉乘的结果其实是向量，方向垂直于两个向量组成的平面，这里我们只需要其大小和方向 double CrossProduct(const Vector2d vec) &#123; return x_*vec.y_ - y_*vec.x_; &#125; //二维向量点积 double DotProduct(const Vector2d vec) &#123; return x_ * vec.x_ + y_ * vec.y_; &#125; //二维向量减法 Vector2d Minus(const Vector2d vec) const &#123; return Vector2d(x_ - vec.x_, y_ - vec.y_); &#125; //判断点M,N是否在直线AB的同一侧 static bool IsPointAtSameSideOfLine(const Vector2d &amp;pointM, const Vector2d &amp;pointN, const Vector2d &amp;pointA, const Vector2d &amp;pointB) &#123; Vector2d AB = pointB.Minus(pointA); Vector2d AM = pointM.Minus(pointA); Vector2d AN = pointN.Minus(pointA); //等于0时表示某个点在直线上 return AB.CrossProduct(AM) * AB.CrossProduct(AN) &gt;= 0; &#125;&#125;; //三角形类class Triangle&#123;public: Vector2d pointA_, pointB_, pointC_; public: Triangle(Vector2d point1, Vector2d point2, Vector2d point3) :pointA_(point1), pointB_(point2), pointC_(point3)&#123;&#125; //记得判断三点是否共线 Triangle():pointA_(), pointB_(), pointC_()&#123;&#125;; //计算三角形面积 double ComputeTriangleArea() &#123; //依据两个向量的叉乘来计算 Vector2d AB = pointB_.Minus(pointA_); Vector2d BC = pointC_.Minus(pointB_); return fabs(AB.CrossProduct(BC) / 2.0); &#125; //通过判断面积是否相等 bool IsPointInTriangle1(const Vector2d pointP) &#123; double area_ABC = ComputeTriangleArea(); double area_PAB = Triangle(pointP, pointA_, pointB_).ComputeTriangleArea(); double area_PAC = Triangle(pointP, pointA_, pointC_).ComputeTriangleArea(); double area_PBC = Triangle(pointP, pointB_, pointC_).ComputeTriangleArea(); if(fabs(area_PAB + area_PBC + area_PAC - area_ABC) &lt; 0.000001) return true; else return false; &#125; //通过判断点在直线同侧 bool IsPointInTriangle2(const Vector2d pointP) &#123; return Vector2d::IsPointAtSameSideOfLine(pointP, pointA_, pointB_, pointC_) &amp;&amp; Vector2d::IsPointAtSameSideOfLine(pointP, pointB_, pointA_, pointC_) &amp;&amp; Vector2d::IsPointAtSameSideOfLine(pointP, pointC_, pointA_, pointB_); &#125; //根据向量基本定理和点在三角形内部充要条件判断 bool IsPointInTriangle3(const Vector2d pointP) &#123; Vector2d AB = pointB_.Minus(pointA_); Vector2d AC = pointC_.Minus(pointA_); Vector2d AP = pointP.Minus(pointA_); double dot_ac_ac = AC.DotProduct(AC); double dot_ac_ab = AC.DotProduct(AB); double dot_ac_ap = AC.DotProduct(AP); double dot_ab_ab = AB.DotProduct(AB); double dot_ab_ap = AB.DotProduct(AP); double tmp = 1.0 / (dot_ac_ac * dot_ab_ab - dot_ac_ab * dot_ac_ab); double u = (dot_ab_ab * dot_ac_ap - dot_ac_ab * dot_ab_ap) * tmp; if(u &lt; 0 || u &gt; 1) return false; double v = (dot_ac_ac * dot_ab_ap - dot_ac_ab * dot_ac_ap) * tmp; if(v &lt; 0 || v &gt; 1) return false; return u + v &lt;= 1; &#125; // t1 = PA^PB, t2 = PB^PC, t3 = PC^PA, t1,t2,t3 同号则 P在三角形内部 bool IsPointInTriangle4(const Vector2d pointP) &#123; Vector2d PA = pointA_.Minus(pointP); Vector2d PB = pointB_.Minus(pointP); Vector2d PC = pointC_.Minus(pointP); double t1 = PA.CrossProduct(PB); double t2 = PB.CrossProduct(PC); double t3 = PC.CrossProduct(PA); return t1*t2 &gt;= 0 &amp;&amp; t1*t3 &gt;= 0 &amp;&amp;t2*t3&gt;=0; &#125;&#125;;int main()&#123; Triangle a; while(scanf(&quot;%lf%lf%lf%lf%lf%lf&quot;,&amp;a.pointA_.x_,&amp;a.pointA_.y_,&amp;a.pointB_.x_,&amp;a.pointB_.y_,&amp;a.pointC_.x_,&amp;a.pointC_.y_)!=EOF)&#123; Vector2d p; scanf(&quot;%lf%lf&quot;,&amp;p.x_,&amp;p.y_); if(a.IsPointInTriangle1(p))\tprintf(&quot;YES &quot;); else printf(&quot;NO &quot;);\t&#125; return 0;&#125; 转载 山海亦可平","categories":["Unity"]},{"title":"WWW 下载的照片方向不正确","path":"/2025/03/24/WWW-下载的照片方向不正确/","content":"原因通过www下载照片，在显示后会出现旋转的现象 通过查询资料发现，是照片自带的 Exif信息中包含旋转信息,因此我们需要根据Exif 旋转照片到正确方向 可交换图像文件格式（英语：Exchangeable image file format，官方简称Exif），是专门为数码相机的照片设定的，可以记录数码照片的属性信息和拍摄数据 Unity 读取jpg照片 Exif信息1234567891011121314151617181920212223/// &lt;summary&gt;/// 读取jpg照片信息/// &lt;/summary&gt;/// &lt;param name=&quot;fiBYTES&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;Name&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static JpegInfo ReadJpeg(this byte[] fiBYTES, string Name)&#123; DateTime then = DateTime.Now; using (MemoryStream fs = new MemoryStream(fiBYTES)) &#123; ExifReader reader = new ExifReader(fs) &#123; info = &#123; FileSize = (int)fs.Length, FileName = Name, LoadTime = (DateTime.Now - then) &#125; &#125;; return reader.info; &#125;&#125; 下载并旋转到正确方向1234567891011121314151617181920212223242526272829303132333435363738394041 IEnumerator AsyDownload(string url) &#123; WWW www = new WWW(url); yield return www; if (!string.IsNullOrEmpty(www.error)) &#123; Debug.LogError(&quot;下载错误&quot;); &#125; else if (www.isDone) &#123; var texture = www.texture; try &#123; var jpgInfo = www.bytes.ReadJpeg(&quot;&quot;); if (jpgInfo.IsValid) &#123; switch (jpgInfo.Orientation) &#123; case ExifOrientation.BottomLeft: texture = texture.RotationRight90(); break; case ExifOrientation.BottomRight: texture = texture.RotationRight90(); break; case ExifOrientation.TopRight: // 验证了此处 texture = texture.RotationRight90(); break; case ExifOrientation.TopLeft: break; &#125; &#125; &#125; catch (Exception e) &#123; Debug.Log(&quot;不存在 exif 信息&quot;); &#125; Image.texture = texture; &#125;&#125; 旋转图片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public static class TextureExtent&#123; /// &lt;summary&gt; /// 创建新尺寸的 Texture /// &lt;/summary&gt; /// &lt;param name=&quot;tex&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;width&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;height&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Texture NewSize(this Texture tex, int width, int height) &#123; if (null == tex) return null; tex.filterMode = FilterMode.Point; RenderTexture rt = RenderTexture.GetTemporary(width, height); rt.filterMode = FilterMode.Point; RenderTexture.active = rt; Graphics.Blit(tex, rt); var nTex = new Texture2D(width, height); nTex.ReadPixels(new Rect(0, 0, width, height), 0, 0); nTex.Apply(); RenderTexture.active = null; return nTex; &#125; /// &lt;summary&gt; /// 图片逆时针旋转90度 /// &lt;/summary&gt; /// &lt;param name=&quot;src&quot;&gt;原图片二进制数据&lt;/param&gt; /// &lt;param name=&quot;srcW&quot;&gt;原图片宽度&lt;/param&gt; /// &lt;param name=&quot;srcH&quot;&gt;原图片高度&lt;/param&gt; /// &lt;param name=&quot;desTexture&quot;&gt;输出目标图片&lt;/param&gt; public static Texture2D RotationLeft90(this Texture2D originalTexture) &#123; Color32[] src = originalTexture.GetPixels32(); Color32[] des = new Color32[src.Length]; int srcW = originalTexture.width; int srcH = originalTexture.height; Texture2D desTexture = new Texture2D(srcH, srcW); if (desTexture.width != srcH || desTexture.height != srcW) &#123; desTexture.Reinitialize(srcH, srcW); &#125; for (int i = 0; i &lt; srcW; i++) &#123; for (int j = 0; j &lt; srcH; j++) &#123; des[i * srcH + j] = src[(srcH - 1 - j) * srcW + i]; &#125; &#125; desTexture.SetPixels32(des); desTexture.Apply(); return desTexture; &#125; /// &lt;summary&gt; /// 图片顺时针旋转90度 /// &lt;/summary&gt; /// &lt;param name=&quot;src&quot;&gt;原图片二进制数据&lt;/param&gt; /// &lt;param name=&quot;srcW&quot;&gt;原图片宽度&lt;/param&gt; /// &lt;param name=&quot;srcH&quot;&gt;原图片高度&lt;/param&gt; /// &lt;param name=&quot;desTexture&quot;&gt;输出目标图片&lt;/param&gt; public static Texture2D RotationRight90(this Texture2D originalTexture) &#123; Color32[] src = originalTexture.GetPixels32(); Color32[] des = new Color32[src.Length]; int srcW = originalTexture.width; int srcH = originalTexture.height; Texture2D desTexture = new Texture2D(srcH, srcW); for (int i = 0; i &lt; srcH; i++) for (int j = 0; j &lt; srcW; j++) des[(srcW - j - 1) * srcH + i] = src[i * srcW + j]; desTexture.SetPixels32(des); desTexture.Apply(); return desTexture; &#125; /// &lt;summary&gt; /// 图片旋转180度 /// &lt;/summary&gt; /// &lt;param name=&quot;src&quot;&gt;原图片二进制数据&lt;/param&gt; /// &lt;param name=&quot;srcW&quot;&gt;原图片宽度&lt;/param&gt; /// &lt;param name=&quot;srcH&quot;&gt;原图片高度&lt;/param&gt; /// &lt;param name=&quot;desTexture&quot;&gt;输出目标图片&lt;/param&gt; public static Texture2D Rotation180(this Texture2D originalTexture) &#123; Color32[] src = originalTexture.GetPixels32(); Color32[] des = new Color32[src.Length]; int srcW = originalTexture.width; int srcH = originalTexture.height; Texture2D desTexture = new Texture2D(srcW, srcH); for (int i = 0; i &lt; srcH; i++) &#123; for (int j = 0; j &lt; srcW; j++) &#123; des[i * srcW + j] = src[(srcH - i) * srcW - j - 1]; &#125; &#125; desTexture.SetPixels32(des); desTexture.Apply(); return desTexture; &#125; &#125; 旋转后的图片 ExifLib 库下载 Unity 讨论区 Exif 介绍 Exif Demo ExifLib 库下载地址 需要科学上网 图片旋转","tags":["UI"],"categories":["Unity"]},{"title":"UGUI 绘制线","path":"/2025/03/24/UGUI-绘制线/","content":"简单记录暂无例程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150using System;using System.Collections.Generic;using System.Linq;using UnityEngine;using UnityEngine.UI;public class UICurve : MaskableGraphic&#123; public UICurveData GetCurveData(int id) &#123; UICurveData curveData; if (dCurveData.TryGetValue(id, out curveData)) &#123; return curveData; &#125; return null; &#125; public void ResetDraw() &#123; SetAllDirty(); &#125; public void AddCurveData(int id, UICurveData curveData) &#123; dCurveData.Add(id, curveData); &#125; public void AddCurveData(UICurveData curveData) &#123; dCurveData.Add(dCurveData.Count, curveData); &#125; public void Clear() &#123; dCurveData.Clear(); SetAllDirty(); &#125; public Dictionary&lt;int, UICurveData&gt; dCurveData = new Dictionary&lt;int, UICurveData&gt;(); // protected override void Start() // &#123; // base.Start(); // // var point1 = new UICurveData(); // point1.AddPos(0, 0); // point1.AddPos(100, 100); // var point2 = new UICurveData(); // // point2.AddPos(1000, 1000); // point2.AddPos(1000, 1100); // dCurveData.Add(0, point1); // dCurveData.Add(1, point2); // // ResetDraw(); // &#125; protected override void OnPopulateMesh(VertexHelper vh) &#123; vh.Clear(); if (dCurveData == null) &#123; return; &#125; foreach (var cd in dCurveData) &#123; var lCurveData = cd.Value; if (lCurveData.pos.Count &lt; 2) &#123; continue; &#125; for (int i = 1; i &lt; lCurveData.pos.Count; i++) &#123; UIVertex[] verts = new UIVertex[4]; float x1 = lCurveData.pos[i - 1].x; float y1 = lCurveData.pos[i - 1].y; float x2 = lCurveData.pos[i].x; float y2 = lCurveData.pos[i].y; float xd = (y2 - y1) / Mathf.Sqrt(Mathf.Pow(x2 - x1, 2) + Mathf.Pow(y2 - y1, 2)) * cd.Value.thickness / 2; float yd = (x2 - x1) / Mathf.Sqrt(Mathf.Pow(x2 - x1, 2) + Mathf.Pow(y2 - y1, 2)) * cd.Value.thickness / 2; int idx = 0; verts[idx].position = new Vector3(lCurveData.pos[i - 1].x - xd, lCurveData.pos[i - 1].y + yd); verts[idx].color = lCurveData.color; verts[idx].uv0 = Vector2.zero; idx++; verts[idx].position = new Vector3(lCurveData.pos[i].x - xd, lCurveData.pos[i].y + yd); verts[idx].color = lCurveData.color; verts[idx].uv0 = Vector2.zero; idx++; verts[idx].position = new Vector3(lCurveData.pos[i].x + xd, lCurveData.pos[i].y - yd); verts[idx].color = lCurveData.color; verts[idx].uv0 = Vector2.zero; idx++; verts[idx].position = new Vector3(lCurveData.pos[i - 1].x + xd, lCurveData.pos[i - 1].y - yd); verts[idx].color = lCurveData.color; verts[idx].uv0 = Vector2.zero; vh.AddUIVertexQuad(verts); &#125; &#125; &#125; internal void RemovePointIDs(params int[] remotePointIDs) &#123; RemovePointIDs(remotePointIDs.ToList()); &#125; internal void RemovePointIDs(List&lt;int&gt; lRemotePointIDs) &#123; foreach (var i in lRemotePointIDs) &#123; if (!dCurveData.ContainsKey(i)) &#123; continue; &#125; dCurveData.Remove(i); &#125; SetAllDirty(); &#125;&#125;[Serializable]public class UICurveData&#123; public List&lt;Vector2&gt; pos = new List&lt;Vector2&gt;(); public Color color = Color.white; public float thickness = 10; public void AddPos(Vector2 v) &#123; pos.Add(v); &#125; public void AddPos(float x, float y) &#123; AddPos(new Vector2(x, y)); &#125;&#125;","tags":["UI"],"categories":["Unity"]},{"title":"自动同步动态公网Ip到阿里云","path":"/2025/03/24/自动同步动态公网Ip到阿里云/","content":"使用python把家里的动态公网IP自动同步到阿里云域名下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#!/usr/bin/env python3# coding=utf-8# 加载核心SDKimport refrom aliyunsdkcore.client import AcsClientfrom aliyunsdkcore.acs_exception.exceptions import ClientExceptionfrom aliyunsdkcore.acs_exception.exceptions import ServerException# 加载获取 、 新增、 更新、 删除接口from aliyunsdkalidns.request.v20150109 import DescribeSubDomainRecordsRequest, AddDomainRecordRequest, \\ UpdateDomainRecordRequest, DeleteDomainRecordRequest# 加载内置模块import json, urllib# AccessKey 和 Secret 建议使用 RAM 子账户的 KEY 和 SECRET 增加安全性ID = &#x27;AccessKey&#x27;SECRET = &#x27;Secret&#x27;# 地区节点 可选地区取决于你的阿里云帐号等级，普通用户只有四个，分别是杭州、上海、深圳、河北，具体参考官网APIregionId = &#x27;cn-hangzhou&#x27;# 配置认证信息client = AcsClient(ID, SECRET, regionId)# 设置主域名DomainName = &#x27;xclikee.top&#x27;# 子域名列表 列表参数可根据实际需求增加或减少值SubDomainList = [&#x27;www&#x27;, &#x27;a&#x27;, &#x27;@&#x27;]# 查询记录def getDomainInfo(SubDomain): request = DescribeSubDomainRecordsRequest.DescribeSubDomainRecordsRequest() request.set_accept_format(&#x27;json&#x27;) # 设置要查询的记录类型为 A记录 官网支持A / CNAME / MX / AAAA / TXT / NS / SRV / CAA / URL隐性（显性）转发 如果有需要可将该值配置为参数传入 request.set_Type(&quot;A&quot;) # 指定查记的域名 格式为 &#x27;test.example.com&#x27; request.set_SubDomain(SubDomain) response = client.do_action_with_exception(request) response = str(response, encoding=&#x27;utf-8&#x27;) # 将获取到的记录转换成json对象并返回 return json.loads(response)# 新增记录 (默认都设置为A记录，通过配置set_Type可设置为其他记录)def addDomainRecord(client, value, rr, domainname): request = AddDomainRecordRequest.AddDomainRecordRequest() request.set_accept_format(&#x27;json&#x27;) # request.set_Priority(&#x27;1&#x27;) # MX 记录时的必选参数 request.set_TTL(&#x27;600&#x27;) # 可选值的范围取决于你的阿里云账户等级，免费版为 600 - 86400 单位为秒 request.set_Value(value) # 新增的 ip 地址 request.set_Type(&#x27;A&#x27;) # 记录类型 request.set_RR(rr) # 子域名名称 request.set_DomainName(domainname) # 主域名 # 获取记录信息，返回信息中包含 TotalCount 字段，表示获取到的记录条数 0 表示没有记录， 其他数字为多少表示有多少条相同记录，正常有记录的值应该为1，如果值大于1则应该检查是不是重复添加了相同的记录 response = client.do_action_with_exception(request) response = str(response, encoding=&#x27;utf-8&#x27;) relsult = json.loads(response) return relsult# 更新记录def updateDomainRecord(client, value, rr, record_id): request = UpdateDomainRecordRequest.UpdateDomainRecordRequest() request.set_accept_format(&#x27;json&#x27;) # request.set_Priority(&#x27;1&#x27;) request.set_TTL(&#x27;600&#x27;) request.set_Value(value) # 新的ip地址 request.set_Type(&#x27;A&#x27;) request.set_RR(rr) request.set_RecordId(record_id) # 更新记录需要指定 record_id ，该字段为记录的唯一标识，可以在获取方法的返回信息中得到该字段的值 response = client.do_action_with_exception(request) response = str(response, encoding=&#x27;utf-8&#x27;) return response# 删除记录def delDomainRecord(client, subdomain): info = getDomainInfo(subdomain) if info[&#x27;TotalCount&#x27;] == 0: print(&#x27;没有相关的记录信息，删除失败！&#x27;) elif info[&quot;TotalCount&quot;] == 1: print(&#x27;准备删除记录&#x27;) request = DeleteDomainRecordRequest.DeleteDomainRecordRequest() request.set_accept_format(&#x27;json&#x27;) record_id = info[&quot;DomainRecords&quot;][&quot;Record&quot;][0][&quot;RecordId&quot;] request.set_RecordId(record_id) # 删除记录需要指定 record_id ，该字段为记录的唯一标识，可以在获取方法的返回信息中得到该字段的值 result = client.do_action_with_exception(request) print(&#x27;删除成功，返回信息：&#x27;) print(result) else: # 正常不应该有多条相同的记录，如果存在这种情况，应该手动去网站检查核实是否有操作失误 print(&quot;存在多个相同子域名解析记录值，请核查后再操作！&quot;)# 有记录则更新，没有记录则新增def setDomainRecord(client, value, rr, domainname): info = getDomainInfo(rr + &#x27;.&#x27; + domainname) if info[&#x27;TotalCount&#x27;] == 0: print(&#x27;准备添加新记录&#x27;) add_result = addDomainRecord(client, value, rr, domainname) print(add_result) elif info[&quot;TotalCount&quot;] == 1: print(&#x27;准备更新已有记录&#x27;) record_id = info[&quot;DomainRecords&quot;][&quot;Record&quot;][0][&quot;RecordId&quot;] cur_ip = getIp() old_ip = info[&quot;DomainRecords&quot;][&quot;Record&quot;][0][&quot;Value&quot;] if cur_ip == old_ip: print(&quot;新ip与原ip相同，无法更新！&quot;) else: update_result = updateDomainRecord(client, value, rr, record_id) print(&#x27;更新成功，返回信息：&#x27;) print(update_result) else: # 正常不应该有多条相同的记录，如果存在这种情况，应该手动去网站检查核实是否有操作失误 print(&quot;存在多个相同子域名解析记录值，请核查删除后再操作！&quot;)def Request(url): try: with urllib.request.urlopen(url, timeout=2) as response: return response.read() except Exception as e: print(url + &quot;请求错误：&quot; + e) return None# 获取外网IP 捅过正则表达式 提取IP# 以防其中过一个挂掉了多配置几条查询网站def getIp(): # 备选地址： # http://pv.sohu.com/cityjson?ie=utf-8 2，curl -L tool.lu/ip # http://myip.ipip.net/ # https://ifconfig.me/ urlList = [&#x27;http://pv.sohu.com/cityjson?ie=utf-8&#x27;, &#x27; http://myip.ipip.net/&#x27;, &#x27;https://ifconfig.me/&#x27; ] ip = None for url in urlList: html = Request(&#x27;http://myip.ipip.net/&#x27;) if html is not None: content = str(html, encoding=&#x27;utf-8&#x27;) try: reIp = re.search(r&#x27;((2(5[0-5]|[0-4]\\d))|[0-1]?\\d&#123;1,2&#125;)(\\.((2(5[0-5]|[0-4]\\d))|[0-1]?\\d&#123;1,2&#125;))&#123;3&#125;&#x27;, content) if reIp is not None: return reIp.group() except: pass return ipIP = getIp()if IP is None: print(&quot;Ip 地址获取失败&quot;)else: print(IP) # 循环子域名列表进行批量操作 for x in SubDomainList: setDomainRecord(client, IP, x, DomainName)","categories":["Python"]},{"title":"MySQL数据库中随机获取一条或多条记录","path":"/2025/03/24/MySQL数据库中随机获取一条或多条记录/","content":"工作中会遇到从数据库中随机获取一条或多条记录的场景，下面介绍几种随机获取的方法供参考。首先创建个users表演示 123456CREATE TABLE `users` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) DEFAULT NULL, `age` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 1.使用order by rand()SELECT * FROM users ORDER BY RAND() LIMIT 1; LIMIT 1的执行时间：0.559s, LIMIT 100 耗时0.660s。 此种方法在数据量小的情况下可以使用，但在生产环境不建议使用。 MYSQL手册里面针对RAND()的提示大概意思就是，在 ORDER BY从句里面不能使用RAND()函数，因为这样会导致数据列被多次扫描，导致效率相当相当的低，效率不行，切忌使用。 2.使用join及rand()函数12SELECT * FROM users AS t1 JOIN (SELECT ROUND(RAND()*(SELECT MAX(id)FROM users)) AS id) AS t2 WHERE t1.id&gt;=t2.id ORDER BY t1.id LIMIT 1; 此sql随机获取一条的时间是0.014s，LIMIT 100时耗时 0.020s，性能上没差多少。 获取多条的话有时会达不到要求(获取的记录数可能达不到多条) 3.子查询及rand()函数SELECT * FROM users as t1 WHERE t1.id&gt;=(RAND()*(SELECT MAX(id) FROM users)) LIMIT 1; 随机去一条的耗时：0.015，LIMIT 100时耗时 0.026s。 随机获取一条记录推荐使用 第2种方法，在30万条记录时也只需0.014s。","tags":["Mysql"],"categories":["mysql"]},{"title":"记录 UnityHub 莫名进入全屏模式且无法退出","path":"/2025/03/24/记录UnityHub莫名进入全屏模式且无法退出/","content":"起因国庆小长假结束后，回到工位擦拭键盘的时候不知道按到了那个键，导致UnityHub 进去全屏模式，而且无法退出。 F11、ESC卸载重装都不起作用 如图 找不到最大化、最小化等按钮 解决方式打开 C:\\Users\\(用户)\\AppData\\Roaming\\UnityHub\\main-window.json 把其中 &quot;isFullScreen&quot;: true 改成 &quot;isFullScreen&quot;: false 然后退出重启 Unity Hub 就可以了"},{"title":"Mysql多表联查，查询结果出现重复的原因和解决方法","path":"/2025/03/24/多表联查查询结果出现重复的原因和解决方法/","content":"背景突然发现博客列表页会出现重复的项，原以为是程序BUG（数据多储存了）。经检查发现 是SQL查询结果出现重复项 123456789101112131415SELECT articles_id,\tarticles_title,\tarticles_date FROM\t`articles`\tINNER JOIN `article_sort` ON article_sort.article_id = articles.articles_id\tINNER JOIN `sorts` ON sorts.sort_id = article_sort.sort_id WHERE\t(\tsorts.sort_name = &quot;&quot;unity&quot;&quot;) AND (\tarticles.articles_state = 1) ORDER BY\t`articles_date` DESC 数据库 显示结果 解决办法当时直接想到的是加DISTINCT进行去重，效果确实能够达到且立竿见影，除此之外，也可以在语句末尾添加group by b_id来实现同样的效果。但是不能只知其然，后来发现，是自己join的表没有关联主键或者说是value唯一性的字段。通过对该表以该字段查询后发现确实存在两行数据，换言之，如果在c表中查询该字段对应的数据后即SELECT * FROM c WHERE c.network_id = &#39;123456789&#39;结果显示数据有n行，那么根据笛卡尔积，left join 将会产生m * n条数据，会重复n倍。 原文连接DISTINCT从表中查询数据时，可能会收到重复的行记录。为了删除这些重复行，可以在SELECT语句中使用 DISTINCT 子句 DISTINCT子句的语法如下 123456SELECT DISTINCT columnsFROM table_nameWHERE where_conditions; MySQL DISTINCT语句背景突然发现博客列表页会出现重复的项，原以为是程序BUG（数据多储存了）。经检查发现 是SQL查询结果出现重复项 123456789101112131415SELECT articles_id,\tarticles_title,\tarticles_date FROM\t`articles`\tINNER JOIN `article_sort` ON article_sort.article_id = articles.articles_id\tINNER JOIN `sorts` ON sorts.sort_id = article_sort.sort_id WHERE\t(\tsorts.sort_name = &quot;&quot;unity&quot;&quot;) AND (\tarticles.articles_state = 1) ORDER BY\t`articles_date` DESC 数据库 显示结果 解决办法当时直接想到的是加DISTINCT进行去重，效果确实能够达到且立竿见影，除此之外，也可以在语句末尾添加group by b_id来实现同样的效果。但是不能只知其然，后来发现，是自己join的表没有关联主键或者说是value唯一性的字段。通过对该表以该字段查询后发现确实存在两行数据，换言之，如果在c表中查询该字段对应的数据后即SELECT * FROM c WHERE c.network_id = &#39;123456789&#39;结果显示数据有n行，那么根据笛卡尔积，left join 将会产生m * n条数据，会重复n倍。 原文连接","tags":["Mysql"],"categories":["MYSQL"]},{"title":"C# 标准的MD5加密32位","path":"/2025/03/24/标准的MD5加密32位/","content":"标准的MD5加密32位小写的 使用此方法有可能生成小鱼32位的md5 无补位123456789101112131415public static string GetMD5(string myString) &#123; MD5 md5 = new MD5CryptoServiceProvider(); //byte[] fromData = System.Text.Encoding.Unicode.GetBytes(myString); byte[] fromData = System.Text.Encoding.UTF8.GetBytes(myString);// byte[] targetData = md5.ComputeHash(fromData); string byte2String = null; for (int i = 0; i &lt; targetData.Length; i++) &#123; byte2String += targetData[i].ToString(&quot;x&quot;); &#125; return byte2String; &#125; 有补位1234567891011121314151617public static string GetMD5(string myString) &#123; MD5 md5 = new MD5CryptoServiceProvider(); //byte[] fromData = System.Text.Encoding.Unicode.GetBytes(myString); byte[] fromData = System.Text.Encoding.UTF8.GetBytes(myString);// byte[] targetData = md5.ComputeHash(fromData); string byte2String = null; for (int i = 0; i &lt; targetData.Length; i++) &#123; //这个是很常见的错误，你字节转换成字符串的时候要保证是2位宽度啊，某个字节为0转换成字符串的时候必须是00的，否则就会丢失位数啊。不仅是0，1～9也一样。 //byte2String += targetData[i].ToString(&quot;x&quot;);//这个会丢失 byte2String = byte2String+ targetData[i].ToString(&quot;x2&quot;); &#125; return byte2String; &#125;","categories":["C#"]},{"title":"UI置灰shader","path":"/2025/03/24/UI置灰shader/","content":"####更改UGUI为灰色 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960Shader &quot;Hidden/UIGrey&quot;&#123; Properties &#123; _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125; &#125; SubShader &#123; Cull Off ZWrite Off ZTest Always Tags &#123; &quot;Queue&quot; = &quot;AlphaTest&quot; &quot;IgnoreProjector&quot; = &quot;Ture&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot; &#125; ZWrite off Blend SrcAlpha OneMinusSrcAlpha Pass &#123; CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;UnityCG.cginc&quot; struct appdata &#123; float4 vertex : POSITION; float2 uv : TEXCOORD0; &#125;; struct v2f &#123; float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; &#125;; v2f vert(appdata v) &#123; v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = v.uv; return o; &#125; sampler2D _MainTex; fixed4 frag(v2f i) : SV_Target &#123; fixed4 col = tex2D(_MainTex, i.uv); float grey = dot(col.rgb, float3(0.299, 0.587, 0.114)); col.rgb = float3(grey, grey, grey); return col; &#125; ENDCG &#125; &#125;&#125;","tags":["UI"],"categories":["Unity"]},{"title":"platformio-ide.build 错误","path":"/2025/03/24/platformio-ide-build-错误/","content":"platformio-ide.buildPlatformIO: IntelliSense Index Rebuild 卡住command &#39;platformio-ide.build&#39; not found 无法编译. 因为新版本的pio生成.vscode文件夹和c++环境冲突了. 主要是在生成 项目目录/.vscode/c_cpp_properties.json文件的时候. 解决方案一vscode 设置--pio--Auto Rebuild Autocomplete Index (取消勾选) 重启vscode 解决方案二卡住PlatformIO: IntelliSense Index Rebuild 可以强制结束所有python进程. 先手动删除 项目目录/.vscode文件夹 然后pio 命令行输入 pio init --ide vscode 手动生成即可. 原文连接","tags":["PlatformIO"],"categories":["PlatformIO"]},{"title":"Unity 控制HDR Color Intensity","path":"/2025/03/24/Unity-控制HDR-Color-Intensity/","content":"123456float factor = Mathf.Pow(2,intensity);Color color = new Color(baseColor.r * factor,baseColor.g * factor,baseColor.b * factor);Color hdrColor = baseColor * factor; intensity 强度baseColor 基础颜色 以下暂未验证HDRcolor面板的intensity 获取 1234567891011121314151617181920212223242526272829303132private void Start() &#123; Color32 color32; float exp; DecomposeHdrColor(color, out color32, out exp); Debug.Log(exp); &#125; private const byte k_MaxByteForOverexposedColor = 191; public static void DecomposeHdrColor(Color linearColorHdr, out Color32 baseLinearColor, out float exposure) &#123; baseLinearColor = linearColorHdr; var maxColorComponent = linearColorHdr.maxColorComponent; // replicate Photoshops&#x27;s decomposition behaviour if (maxColorComponent == 0f || maxColorComponent &lt;= 1f &amp;&amp; maxColorComponent &gt;= 1 / 255f) &#123; exposure = 0f; baseLinearColor.r = (byte)Mathf.RoundToInt(linearColorHdr.r * 255f); baseLinearColor.g = (byte)Mathf.RoundToInt(linearColorHdr.g * 255f); baseLinearColor.b = (byte)Mathf.RoundToInt(linearColorHdr.b * 255f); &#125; else &#123; // calibrate exposure to the max float color component var scaleFactor = k_MaxByteForOverexposedColor / maxColorComponent; exposure = Mathf.Log(255f / scaleFactor) / Mathf.Log(2f); // maintain maximal integrity of byte values to prevent off-by-one errors when scaling up a color one component at a time baseLinearColor.r = Math.Min(k_MaxByteForOverexposedColor, (byte)Mathf.CeilToInt(scaleFactor * linearColorHdr.r)); baseLinearColor.g = Math.Min(k_MaxByteForOverexposedColor, (byte)Mathf.CeilToInt(scaleFactor * linearColorHdr.g)); baseLinearColor.b = Math.Min(k_MaxByteForOverexposedColor, (byte)Mathf.CeilToInt(scaleFactor * linearColorHdr.b)); &#125; &#125;","tags":["UI"],"categories":["Unity"]},{"title":"UGUI 竖排文本方案","path":"/2025/03/24/UGUI-竖排文本方案/","content":"今天遇到了一个需求，需要将文本竖排排列，查到了一个网上的方案但是这个方案有几个问题(BUG) 文本的位置会跟着锚点变化 每行的最后几个字的布局是错的 因为他是基于横版的文本排版结果，所以文本框的宽度也会影响他的换行，而且会造成文本框的大小范围和文本的不一致于是我在他原来的思路上把它继续改进了下，并且增加了注释便于理解思路就是重新实现一套排版机制，对换行符特殊处理，然后继续沿用原来修改顶点位置的方案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114using UnityEngine; using UnityEngine.UI;[AddComponentMenu(&quot;&quot;UI/TextVerticalCompoent&quot;&quot;, 10)]public class TextVerticalCompoent : Text &#123; public bool m_Virtical = true; private float lineSpace = 1; private float textSpace = 1; private float xOffset = 0; private float yOffset = 0;#if UNITY_EDITOR protected override void OnValidate() &#123; base.OnValidate(); //关闭自动裁切文本 //解决有时裁切文本会出错的问题 verticalOverflow = VerticalWrapMode.Overflow; &#125;#endif protected override void OnPopulateMesh(VertexHelper toFill) &#123; base.OnPopulateMesh(toFill); if (m_Virtical) &#123; VirticalText(toFill); &#125; &#125; private void VirticalText(VertexHelper toFill) &#123; if (!IsActive()) return; lineSpace = fontSize * lineSpacing; textSpace = fontSize ; //排除掉锚点变化造成的影响 xOffset = rectTransform.rect.width + rectTransform.rect.x - fontSize / 2; yOffset = rectTransform.rect.height + rectTransform.rect.y - fontSize / 2; //重新计算一版排版 int row = 0; int col = 0; float height = fontSize / 2; int minCount = toFill.currentVertCount / 4; if (rectTransform.rect.height &lt; fontSize) &#123; return; &#125; for (int i = 0; i &lt; minCount; i++) &#123; if (height &gt; rectTransform.rect.height || text[i] == &#x27; &#x27;) &#123; col++; row = 0; height = fontSize / 2; &#125; ModifyText(toFill, i, row, col); if (text[i] != &#x27; &#x27;) &#123; row++; height += fontSize; &#125; &#125; &#125; void ModifyText(VertexHelper helper, int i, int charYPos, int charXPos) &#123; //Text 的绘制是每4个顶点绘制一个字符 //按字符顺序取出顶点，则可以获得字符的位置 //并对其进行修改 //取出原来顶点的位置 UIVertex lb = new UIVertex(); helper.PopulateUIVertex(ref lb, i * 4); UIVertex lt = new UIVertex(); helper.PopulateUIVertex(ref lt, i * 4 + 1); UIVertex rt = new UIVertex(); helper.PopulateUIVertex(ref rt, i * 4 + 2); UIVertex rb = new UIVertex(); helper.PopulateUIVertex(ref rb, i * 4 + 3); //计算文本的中心点 Vector3 center = Vector3.Lerp(lb.position, rt.position, 0.5f); float x = -charXPos * lineSpace + xOffset; float y = -charYPos * textSpace + yOffset; //计算字符新位置 Vector3 pos = new Vector3(x, y, 0); lb.position = lb.position - center + new Vector3(x, y, 0); lt.position = lt.position - center + new Vector3(x, y, 0); rt.position = rt.position - center + new Vector3(x, y, 0); rb.position = rb.position - center + new Vector3(x, y, 0); helper.SetUIVertex(lb, i * 4); helper.SetUIVertex(lt, i * 4 + 1); helper.SetUIVertex(rt, i * 4 + 2); helper.SetUIVertex(rb, i * 4 + 3); &#125;&#125; 也可以点击这里下载这个类 原文地址:一个更好的UGUI 竖排文本方案","tags":["UI"],"categories":["Unity"]},{"title":"Unity同一项目双开方法","path":"/2025/03/24/Unity同一项目双开方法/","content":"使用场景Unity中一个项目只能有一个实例，也就是说如果你想测试多人联机的话，可能就需要打包或两台电脑，都有各自的缺点，这个时候双开项目就是最好的方法了 解决方案 新建txt文件，输入以下代码： 123456789101112%cd%rem set dir=复制出来的项目名 remif not exist %dir%( md %dir% ) rem mklink /J %dir%\\Assets 你的项目名\\Assetsmklink /J %dir%\\ProjectSettings 你的项目名\\ProjectSettingsmklink /J %dir%\\AssetBundles 你的项目名\\AssetBundles 将文件的后缀改成.bat，并把这个文件拖到和项目同级的目录里（注意是和项目同级，不是和Assest文件夹同级） 双击搞定，这个时候就会产生一个新的项目，直接Unity打开就好了","categories":["Unity"]},{"title":"mysql 8.0 操作记录","path":"/2025/03/24/mysql80操作记录/","content":"创建用户1create user &#x27;tone&#x27;@&#x27;%&#x27; identified by &#x27;123123&#x27; 授权123456grant all privileges on *.* to &#x27;tone&#x27;@&#x27;%&#x27; with grant option;// 授权 并且设置远程访问GRANT ALL ON *.* TO &#x27;root&#x27;@&#x27;%&#x27;;// GRANT ALL ON 表示所有权限，% 表示通配所有 host，可以访问远程。ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;你自己的密码&#x27;; 权限刷新1flush privileges; 数据库时区1show VARIA&lt;!--autointro--&gt;","tags":["Mysql"],"categories":["mysql"]},{"title":"Text 每行首字符不出现标点符号","path":"/2025/03/24/Text-每行首字符不出现标点符号/","content":"原因当字符串中带有半角空格，且半角空格后面的字符串内容超过文本剩余显示宽度时，Text组件会将后面的整段文字做换行。这个并不是bug，而是Text组件按照拉丁西语的分词习惯做line break，半角空格相当于分隔符，分隔空格前后的内容，并视之为单词。这种分词规则在西语中是正确的，但用在中文就水土不服了：整段的中文内容，粗暴地按半角空格分成了3部分，第一行空格后面的大段文字被判定为一个单词，剩余宽度无法显示，就被整个换到了第二行。 解决方案解决原理很简单，如果碰到首字符是标点符号，那么就提前一个字符或者多个字符让他换行就可以了。如果对中文排版要求比较高，就要考虑自己动手做Text的布局实现了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980using System.Collections;using System.Collections.Generic;using System.Text;using System.Text.RegularExpressions;using UnityEngine;using UnityEngine.UI;[RequireComponent(typeof(Text))]public class TextFit : MonoBehaviour&#123; /// &lt;summary&gt; /// 用于匹配标点符号（正则表达式） /// &lt;/summary&gt; private readonly string strRegex = @&quot;\\p&#123;P&#125;&quot;; /// &lt;summary&gt; /// 用于存储text组件中的内容 /// &lt;/summary&gt; private System.Text.StringBuilder MExplainText = null; /// &lt;summary&gt; /// 用于存储text生成器中的内容 /// &lt;/summary&gt; private IList&lt;UILineInfo&gt; MExpalinTextLine; public IEnumerator MClearUpExplainMode(string _text) &#123; _text = _text.Replace(&quot; &quot;, &quot;&quot;); _text = _text.Replace(&quot;\\t&quot;, &quot;&quot;); _text = _text.Replace(&quot; &quot;, &quot;&quot;); if (_text[0] != &#x27;\\u3000&#x27;) &#123; _text = &quot;\\u3000\\u3000&quot; + _text; _text = _text.Replace(&quot; &quot;, &quot; \\u3000\\u3000&quot;); &#125; Text _component = transform.GetComponent&lt;Text&gt;(); _component.text = _text; yield return new WaitForSeconds(0.001f); MExpalinTextLine = _component.cachedTextGenerator.lines; //需要改变的字符序号 int mChangeIndex = 0; bool Is_H = false; MExplainText = new System.Text.StringBuilder(_component.text); for (int i = 1; i &lt; MExpalinTextLine.Count; i++) &#123; if (_component.text.Length &gt; MExpalinTextLine[i].startCharIdx) &#123; //首位是否有 bool _b = Regex.IsMatch(_component.text[MExpalinTextLine[i].startCharIdx ].ToString(), strRegex); if (_b) &#123; int DD = 1; while (true) &#123; bool _bb = Regex.IsMatch(_component.text[MExpalinTextLine[i].startCharIdx - DD].ToString(), strRegex); if (!_bb) &#123; Is_H = true; mChangeIndex = MExpalinTextLine[i].startCharIdx - 1; MExplainText.Insert(mChangeIndex - (DD - 1), &quot; &quot;); _component.text = MExplainText.ToString(); StartCoroutine(MClearUpExplainMode(MExplainText.ToString())); break; &#125; else &#123; DD++; &#125; &#125; if (Is_H) break; &#125; &#125; &#125; _component.text = MExplainText.ToString(); &#125;&#125; 使用方法12var textFit = gameObject.GetComponent&lt;TextFit&gt;(); StartCoroutine(textFit.MClearUpExplainMode(info));","tags":["UI"],"categories":["Unity"]},{"title":"Unity自动添加命名空间","path":"/2025/03/24/Unity自动添加命名空间/","content":"代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475using System.IO;using UnityEngine;public class ScriptChange : UnityEditor.AssetModificationProcessor&#123; static string namespaceName = &quot;XC&quot;; /// &lt;summary&gt; /// 将要创建资源时会调用这个函数 /// &lt;/summary&gt; static void OnWillCreateAsset(string path) &#123; //导入资源的路径，不知道具体是什么的时候建议输出查看 Debug.Log(path); string str = path.Replace(&quot;.meta&quot;, &quot;&quot;); string[] splitArgs = str.Split(&#x27;.&#x27;); if (splitArgs[splitArgs.Length - 1].Equals(&quot;cs&quot;)) &#123; //Debug.Log(&quot;导入的是脚本&quot;); string[] newSplitArgs = str.Split(&#x27;/&#x27;); bool isEditor = false; foreach (var item in newSplitArgs) &#123; if (item.Equals(&quot;Editor&quot;)) &#123; isEditor = true; break; ; &#125; &#125; if (isEditor) return; ParseAndChangeScript(str.Substring(6, str.Length - 6)); &#125; &#125; private static void ParseAndChangeScript(string path) &#123; string str = File.ReadAllText(Application.dataPath + path); if (string.IsNullOrEmpty(str)) &#123; Debug.Log(&quot;读取出错了，Application.dataPath=&quot; + Application.dataPath + &quot; path=&quot; + path); return; &#125; string newStr = &quot;&quot;; //增加命名空间 if (!str.Contains(&quot;namespace&quot;)) &#123; if (!string.IsNullOrEmpty(namespaceName)) &#123; int length = str.IndexOf(&quot;public&quot;); newStr += str.Substring(0, length); string extraStr = &quot;&quot;; string[] extraStrs = str.Substring(length, str.Length - length).Replace(&quot;\\r &quot;, &quot; &quot;).Split(&#x27; &#x27;); foreach (var item in extraStrs) &#123; extraStr += &quot;\\t&quot; + item + &quot;\\r &quot;; &#125; newStr += &quot;\\r namespace &quot; + namespaceName + &quot;\\r &#123;\\r &quot; + extraStr + &quot;&#125;&quot;; //newStr = newStr.Replace(&quot; &quot;, &quot;\\r &quot;); //newStr = newStr.Replace(&#x27;\\r&#x27;, &#x27; &#x27;); &#125; else &#123; newStr = str; &#125; File.WriteAllText(Application.dataPath + path, newStr); &#125; &#125;&#125;","tags":["Script"],"categories":["Unity"]},{"title":"检测鼠标所点击的按钮位置是否是透明的","path":"/2025/03/24/检测鼠标所点击的按钮位置是否是透明的/","content":"查找 rayResList 是否存在你所点击的按钮 存在则不是透明的 不存在则是透明的 eventData 为鼠标点击的位置 使用UI事件传递下去的数据即可 123List&lt;RaycastResult&gt; rayResList = new List&lt;RaycastResult&gt;();EventSystem.current.RaycastAll(eventData, rayResList);// 参考链接Unity3d Ugui 24 EventSystem事件机制““Texture2d 缩略图”\t“### 制作Texture2d 的缩略图 更改Texture的尺寸，并返回新尺寸的 texture 用法：var newText = texture.NewSize(128, 128); 123456789101112131415161718192021222324252627282930313233 /// &lt;summary&gt;/// Texture 扩展/// &lt;/summary&gt;public static class TextureExtent&#123; /// &lt;summary&gt; /// 创建新尺寸的 Texture /// &lt;/summary&gt; /// &lt;param name=&quot;tex&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;width&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;height&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Texture NewSize(this Texture tex, int width, int height) &#123; if (null == tex) return null; tex.filterMode = FilterMode.Point; RenderTexture rt = RenderTexture.GetTemporary(width, height); rt.filterMode = FilterMode.Point; RenderTexture.active = rt; Graphics.Blit(tex, rt); var nTex = new Texture2D(width, height); nTex.ReadPixels(new Rect(0, 0, width, height), 0, 0); nTex.Apply(); RenderTexture.active = null; return nTex; &#125;&#125;","tags":["UI"],"categories":["Unity"]},{"title":"修复 PlatformlO 找不到这样的文件或者目录","path":"/2025/03/24/修复PlatformlO找不到这样的文件或者目录/","content":"“构建上传 PlatformIO 程序的时候出现这种错误 12CLI &gt; platformio lib search &quot;header:SPI.h&quot;CLI &gt; platformio lib search &quot;header:xxx.h&quot; 等 在 platformio.ini/lib_deps 添加对应的文件名即可 例如 1234lib_deps =\t库1\t库2\tSPI","tags":["PlatformIO"],"categories":["PlatformIO"]},{"title":"Unity 检测窗口是否被完全遮挡","path":"/2025/03/22/Unity-检测窗口是否被完全遮挡/","content":"废话不多说直接上代码 测试代码123456789101112131415161718192021void TestFun()&#123; // 此处需要写unity程序的标题 IntPtr handle = Win32Api.GetProcessWnd(&quot;测试窗口&quot;); // WPF 程序需要这样使用 // IntPtr currentIntPtr = new WindowInteropHelper(this).Handle; if (Win32Api.IsCover(handle)) &#123; Console.WriteLine(&quot;窗口被完全遮挡&quot;); &#125; else &#123; Console.WriteLine(&quot;窗口未被完全遮挡&quot;); &#125;&#125; 系统API123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236internal class Win32Api&#123; [StructLayout(LayoutKind.Sequential)] public struct Rect &#123; public int Left; public int Top; public int Right; public int Bottom; &#125; /// &lt;summary&gt; /// 获取 Win32 窗口的一些基本信息。 /// &lt;/summary&gt; public readonly struct WindowInfo &#123; public WindowInfo(IntPtr hWnd, string className, string title, bool isVisible, Rectangle bounds) : this() &#123; Hwnd = hWnd; ClassName = className; Title = title; IsVisible = isVisible; Bounds = bounds; &#125; /// &lt;summary&gt; /// 获取窗口句柄。 /// &lt;/summary&gt; public IntPtr Hwnd &#123; get; &#125; /// &lt;summary&gt; /// 获取窗口类名。 /// &lt;/summary&gt; public string ClassName &#123; get; &#125; /// &lt;summary&gt; /// 获取窗口标题。 /// &lt;/summary&gt; public string Title &#123; get; &#125; /// &lt;summary&gt; /// 获取当前窗口是否可见。 /// &lt;/summary&gt; public bool IsVisible &#123; get; &#125; /// &lt;summary&gt; /// 获取窗口当前的位置和尺寸。 /// &lt;/summary&gt; public Rectangle Bounds &#123; get; &#125; /// &lt;summary&gt; /// 获取窗口当前是否是最小化的。 /// &lt;/summary&gt; public bool IsMinimized =&gt; Bounds.Left == -32000 &amp;&amp; Bounds.Top == -32000; &#125; [DllImport(&quot;user32.dll&quot;, SetLastError = true)] public static extern IntPtr GetWindow(IntPtr hwnd, uint windowType); public delegate bool WNDENUMPROC(IntPtr hwnd, int lParam); [DllImport(&quot;user32.dll&quot;, SetLastError = true)] public static extern bool EnumWindows(WNDENUMPROC lpEnumFunc, uint lParam); [DllImport(&quot;user32.dll&quot;, SetLastError = true)] public static extern IntPtr GetParent(IntPtr hWnd); [DllImport(&quot;user32.dll&quot;)] public static extern uint GetWindowThreadProcessId(IntPtr hWnd, ref uint lpdwProcessId); [DllImport(&quot;user32.dll&quot;)] public static extern int GetWindowTextLength(IntPtr hWnd); [DllImport(&quot;User32.dll&quot;, CharSet = CharSet.Auto)] public static extern int GetWindowText(IntPtr hWnd, StringBuilder text, int nMaxCount); [DllImport(&quot;kernel32.dll&quot;)] public static extern void SetLastError(uint dwErrCode); [DllImport(&quot;user32&quot;)] public static extern int GetClassName(IntPtr hWnd, StringBuilder lpString, int nMaxCount); [DllImport(&quot;user32&quot;)] public static extern bool IsWindowVisible(IntPtr hWnd); [DllImport(&quot;user32.dll&quot;)] public static extern int GetWindowRect(IntPtr hwnd, out Rect lpRect); public static IntPtr ptrWnd = IntPtr.Zero; static string Title; /// &lt;summary&gt; /// 获得当前进程的主窗口句柄 /// &lt;/summary&gt; /// &lt;param name=&quot;title&quot;&gt;窗口标题&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static IntPtr GetProcessWnd(string title) &#123; if (ptrWnd == IntPtr.Zero) &#123; Title = title; uint pid = (uint)Process.GetCurrentProcess().Id; // 当前进程 ID bool bResult = EnumWindows(OnWindowEnum, pid); return (!bResult &amp;&amp; Marshal.GetLastWin32Error() == 0) ? ptrWnd : IntPtr.Zero; &#125; return ptrWnd; &#125; static bool OnWindowEnum(IntPtr hwnd, int lParam) &#123; uint id = 0; if (GetParent(hwnd) == IntPtr.Zero) &#123; GetWindowThreadProcessId(hwnd, ref id); if (id == lParam) // 找到进程对应的主窗口句柄 &#123; int length = GetWindowTextLength(hwnd); StringBuilder windowName = new StringBuilder(length + 1); GetWindowText(hwnd, windowName, windowName.Capacity); if (windowName.ToString().CompareTo(Title) == 0) &#123; ptrWnd = hwnd; // 把句柄缓存起来 SetLastError(0); // 设置无错误 return false; // 返回 false 以终止枚举窗口 &#125; &#125; &#125; return true; &#125; public static bool IsCover(IntPtr handle) &#123; var currentWindow = GetWindowDetail(handle); var windows = GetAllAboveWindows(handle); var windowInfos = windows.Where(I =&gt; I.IsVisible &amp;&amp; !I.IsMinimized &amp;&amp; I.Bounds.Width &gt; 1 &amp;&amp; I.Bounds.Height &gt; 1 &amp;&amp; I.Hwnd != handle &amp;&amp; !(I.ClassName.StartsWith(&quot;Shell_&quot;) &amp;&amp; I.ClassName.EndsWith(&quot;TrayWnd&quot;))) .ToList(); foreach (var item in windowInfos) &#123; if (item.Bounds.Contains(currentWindow.Bounds)) return true; &#125; return false; &#125; /// &lt;summary&gt; /// 查找当前用户空间下所有符合条件的窗口（仅查找顶层窗口）。如果不指定条件，将返回所有窗口。 /// &lt;/summary&gt; /// &lt;param name=&quot;match&quot;&gt;过滤窗口的条件。&lt;/param&gt; /// &lt;returns&gt;找到的所有窗口信息。&lt;/returns&gt; public static IReadOnlyList&lt;WindowInfo&gt; FindAll(Predicate&lt;WindowInfo&gt; match = null) &#123; var windowList = new List&lt;WindowInfo&gt;(); EnumWindows(OnWindowEnum, 0); return match == null ? windowList : windowList.FindAll(match); bool OnWindowEnum(IntPtr hWnd, int lparam) &#123; // 仅查找顶层窗口。 if (GetParent(hWnd) == IntPtr.Zero) &#123; var windowDetail = GetWindowDetail(hWnd); // 添加到已找到的窗口列表。 windowList.Add(windowDetail); &#125; return true; &#125; &#125; public static WindowInfo GetWindowDetail(IntPtr hWnd) &#123; // 获取窗口类名。 var lpString = new StringBuilder(512); GetClassName(hWnd, lpString, lpString.Capacity); var className = lpString.ToString(); // 获取窗口标题。 var lptrString = new StringBuilder(512); GetWindowText(hWnd, lptrString, lptrString.Capacity); var title = lptrString.ToString().Trim(); // 获取窗口可见性。 var isVisible = IsWindowVisible(hWnd); // 获取窗口位置和尺寸。 Rect rect = default; GetWindowRect(hWnd, out rect); var bounds = new Rectangle(rect.Left, rect.Top, rect.Right - rect.Left, rect.Bottom - rect.Top); return new WindowInfo(hWnd, className, title, isVisible, bounds); &#125; public static List&lt;WindowInfo&gt; GetAllAboveWindows(IntPtr hwnd) &#123; var windowInfos = new List&lt;WindowInfo&gt;(); var intPtr = GetWindow(hwnd, 3); if (intPtr == IntPtr.Zero) &#123; return windowInfos; &#125; var windowDetail = GetWindowDetail(intPtr); windowInfos.AddRange(GetAllAboveWindows(intPtr)); windowInfos.Add(windowDetail); return windowInfos; &#125; public static List&lt;WindowInfo&gt; GetAllBelowWindows(IntPtr hwnd) &#123; var windowInfos = new List&lt;WindowInfo&gt;(); var intPtr = GetWindow(hwnd, 2); if (intPtr == IntPtr.Zero) &#123; return windowInfos; &#125; var windowDetail = GetWindowDetail(intPtr); windowInfos.AddRange(GetAllBelowWindows(intPtr)); windowInfos.Add(windowDetail); return windowInfos; &#125;&#125;","tags":["Unity","窗口遮挡","Win32"],"categories":["Unity"]}]